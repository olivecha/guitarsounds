<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>guitarsounds.analysis API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>guitarsounds.analysis</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import librosa
from soundfile import write
import IPython.display as ipd
import matplotlib.ticker as ticker
import matplotlib.pyplot as plt
import matplotlib.cm
import numpy as np
import os
from noisereduce.noisereducev1 import reduce_noise
import scipy
import scipy.optimize
import scipy.integrate
import scipy.interpolate
from scipy import signal as sig
from guitarsounds.parameters import sound_parameters
import guitarsounds.utils as utils
from tabulate import tabulate
from timbral_models import timbral_extractor

&#34;&#34;&#34;
Getting the sound parameters from the guitarsounds_parameters.py file
&#34;&#34;&#34;
SP = sound_parameters()

&#34;&#34;&#34;
Classes
&#34;&#34;&#34;

class SoundPack(object):
    &#34;&#34;&#34;
    A class to store and analyse multiple sounds
    Some methods are only available for the case with two sounds
    &#34;&#34;&#34;

    def __init__(self, *sounds, names=None, fundamentals=None, SoundParams=None, equalize_time=True):
        &#34;&#34;&#34;
        The SoundPack can be instantiated from existing Sound class instances, either in a list or as
        multiple arguments

        The class can also handle the creation of Sound class instances if the arguments are filenames,
        either a list or multiple arguments.

        If the number of Sound contained is equal to two, the SoundPack will be &#39;dual&#39; and the associated methods
        will be available

        If it contains multiple sounds the SoundPack will be multiple and a reduced number of methods will work

        A list of names as strings and fundamental frequencies can be specified when creating the SoundPack

        If equalize_time is set to False, the contained sounds will not be trimmed to the same length.

        Examples :
        ```
        Sound_Test = SoundPack(&#39;sounds/test1.wav&#39;, &#39;sounds/test2.wav&#39;, names=[&#39;A&#39;, &#39;B&#39;], fundamentals = [134, 134])

        sounds = [sound1, sound2, sound3, sound4, sound5] # instances of the Sound class
        large_Test = SoundPack(sounds, names=[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;])
        ```
        &#34;&#34;&#34;
        # create a copy of the sound parameters
        if SoundParams is None:
            self.SP = SP
        else:
            self.SP = SoundParams

        # Check if the sounds argument is a list
        if type(sounds[0]) is list:
            sounds = sounds[0]  # unpack the list

        # Check for special case
        if len(sounds) == 2:
            # special case to compare two sounds
            self.kind = &#39;dual&#39;

        elif len(sounds) &gt; 1:
            # general case for multiple sounds
            self.kind = &#39;multiple&#39;

        if type(sounds[0]) is str:
            self.sounds_from_files(sounds, names=names, fundamentals=fundamentals)

        else:
            self.sounds = sounds
            # Assign a default value to names
            if names is None:
                names = [str(n) for n in np.arange(1, len(sounds) + 1)]
                for sound, n in zip(self.sounds, names):
                    sound.name = n

            # sound name defined in constructor
            elif names and (len(names) == len(self.sounds)):
                for sound, n in zip(self.sounds, names):
                    sound.name = n

        if equalize_time:
            self.equalize_time()

        # Define bin strings
        self.bin_strings = [*list(self.SP.bins.__dict__.keys())[1:], &#39;brillance&#39;]

        # Sort according to fundamental
        key = np.argsort([sound.fundamental for sound in self.sounds])
        self.sounds = np.array(self.sounds)[key]

    def sounds_from_files(self, sound_files, names=None, fundamentals=None):
        &#34;&#34;&#34;
        Create Sound class instances and assign them to the SoundPack from a list of files
        :param sound_files: sound filenames
        :param names: sound names
        :param fundamentals: user specified fundamental frequencies
        :return: None
        &#34;&#34;&#34;
        # Make the default name list from sound filenames if none is supplied
        if (names is None) or (len(names) != len(sound_files)):
            names = [file[:-4] for file in sound_files]  # remove the .wav

        # If the fundamentals are not supplied or mismatch in number None is used
        if (fundamentals is None) or (len(fundamentals) != len(sound_files)):
            fundamentals = len(sound_files) * [None]

        # Create Sound instances from files
        self.sounds = []
        for file, name, fundamental in zip(sound_files, names, fundamentals):
            self.sounds.append(Sound(file, name=name, fundamental=fundamental,
                                     SoundParams=self.SP).condition(return_self=True))

    def equalize_time(self):
        &#34;&#34;&#34;
        Trim the sounds so that they all have the length of the shortest sound, trimming is done at the end.
        :return: None
        &#34;&#34;&#34;
        trim_index = np.min([len(sound.signal.signal) for sound in self.sounds])
        trimmed_sounds = []
        for sound in self.sounds:
            new_sound = sound
            new_sound.signal = new_sound.signal.trim_time(trim_index / sound.signal.sr)
            new_sound.bin_divide()
            trimmed_sounds.append(new_sound)
        self.sounds = trimmed_sounds

    def normalize(self):
        &#34;&#34;&#34;
        Normalize all the signals in the SoundPack and returns a normaized
        instance of itself
        :return: SoundPack with normalized signals
        &#34;&#34;&#34;
        new_sounds = []
        names = [sound.name for sound in self.sounds]
        fundamentals = [sound.fundamental for sound in self.sounds]
        for sound in self.sounds:
            sound.signal = sound.signal.normalize()
            new_sounds.append(sound)

        return SoundPack(new_sounds, names=names, fundamentals=fundamentals, SoundParams=self.SP, equalize_time=False)

    &#34;&#34;&#34;
    Methods for all SoundPacks
    &#34;&#34;&#34;

    def plot(self, kind, **kwargs):
        &#34;&#34;&#34;
        Superimposed plot of all the sounds on one figure for a specific kind

        __ Multiple SoundPack Method __
        Plots a specific signal.plot for all sounds on the same figure
        Ex : compare_plot(&#39;fft&#39;) plots the fft of all sounds on a single figure
        The color argument is set to none so that the plots have different colors

        :param kind: Attribute passed to the `signal.plot()` method
        :param kwargs: key words arguments to pass to the `signal.plot()` method
        :return: None
        &#34;&#34;&#34;
        plt.figure(figsize=(8, 6))
        for sound in self.sounds:
            kwargs[&#39;label&#39;] = sound.name
            kwargs[&#39;color&#39;] = None
            sound.signal.old_plot(kind, **kwargs)

        plt.title(kind + &#39; plot&#39;)
        if kind == &#39;timbre&#39;:
            plt.legend(bbox_to_anchor=(1.3, 0.9))
        else:
            plt.legend()

    def compare_plot(self, kind, **kwargs):
        &#34;&#34;&#34;
        Plots all the sounds on different figures to compare them for a specific kind

        __ Multiple SoundPack Method __
        Draws the same kind of plot on a different axis for each sound
        Example : `SoundPack.compare_plot(&#39;peaks&#39;)` with 4 Sounds will plot a figure with 4 axes, with each
        a different &#39;peak&#39; plot.

        :param kind: kind argument passed to `Signal.plot()`
        :param kwargs: key word arguments passed to Signal.plot()
        :return: None
        &#34;&#34;&#34;
        # if a dual SoundPack : only plot two big plots
        if self.kind == &#39;dual&#39;:

            if kind == &#39;timbre&#39;:
                fig, axs = plt.subplots(1, 2, figsize=(8, 4), subplot_kw={&#39;projection&#39;: &#39;polar&#39;})
                for sound, ax in zip(self.sounds, axs):
                    plt.sca(ax)
                    sound.signal.old_plot(kind, **kwargs)
                    ax.set_title(kind + &#39; &#39; + sound.name)

            else:
                fig, axs = plt.subplots(1, 2, figsize=(12, 4))
                for sound, ax in zip(self.sounds, axs):
                    plt.sca(ax)
                    sound.signal.old_plot(kind, **kwargs)
                    ax.set_title(kind + &#39; &#39; + sound.name)
            plt.tight_layout()

        # If a multiple SoundPack : plot on a grid of axes
        elif self.kind == &#39;multiple&#39;:

            # find the n, m values for the subplots line and columns
            n = len(self.sounds)
            if n // 4 &gt;= 10:
                # a lot of sounds
                cols = 4
            elif n // 3 &gt;= 10:
                # many sounds
                cols = 3
            elif n // 2 &lt;= 4:
                # a few sounds
                cols = 2

            remainder = n % cols
            if remainder == 0:
                rows = n // cols
            else:
                rows = n // cols + 1

            fig, axs = plt.subplots(rows, cols, figsize=(12, 4 * rows))
            axs = axs.reshape(-1)
            for sound, ax in zip(self.sounds, axs):
                plt.sca(ax)
                sound.signal.old_plot(kind, **kwargs)
                title = ax.get_title()
                title = sound.name + &#39; &#39; + title
                ax.set_title(title)

            if remainder != 0:
                for ax in axs[-(cols - remainder):]:
                    ax.set_axis_off()

            plt.tight_layout()

    def freq_bin_plot(self, f_bin=&#39;all&#39;):
        &#34;&#34;&#34;
        Plots the log envelop of specified frequency bins

        __ Multiple SoundPack Method __
        A function to compare signals decomposed frequency wise in the time domain on a logarithm scale.
        The methods plots all the sounds and plots their frequency bins according to the frequency bin argument f_bin.

        Example : SoundPack.freq_bin_plot(f_bin=&#39;mid&#39;) will plot the log-scale envelop of the &#39;mid&#39; signal of every
        sound in the SoundPack

        f_bin: frequency bins to compare, Supported arguments are :
        &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
        &#34;&#34;&#34;

        if f_bin == &#39;all&#39;:
            # Create one plot per bin
            fig, axs = plt.subplots(3, 2, figsize=(12, 12))
            axs = axs.reshape(-1)
            for key, ax in zip([*list(self.SP.bins.__dict__.keys())[1:], &#39;brillance&#39;], axs):
                plt.sca(ax)
                # plot every sound for a frequency bin
                norm_factors = np.array([son.bins[key].normalize().norm_factor for son in self.sounds])
                for i, son in enumerate(self.sounds):
                    son.bins[key].normalize().old_plot(&#39;log envelop&#39;, label=son.name)
                plt.xscale(&#39;log&#39;)
                plt.legend()
                title0 = &#39; &#39; + key + &#39; : &#39; + str(int(son.bins[key].range[0])) + &#39; - &#39; + str(
                        int(son.bins[key].range[1])) + &#39; Hz, &#39;
                title1 = &#39;Norm. Factors : &#39;
                title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
                plt.title(title0 + title1 + title2)
            plt.tight_layout()

        elif f_bin in [*list(SP.bins.__dict__.keys())[1:], &#39;brillance&#39;]:
            plt.figure(figsize=(10, 4))
            # Plot every envelop for a single frequency bin
            norm_factors = np.array([son.bins[f_bin].normalize().norm_factor for son in self.sounds])
            for i, son in enumerate(self.sounds):
                son.bins[f_bin].normalize().old_plot(&#39;log envelop&#39;, label=(str(i + 1) + &#39;. &#39; + son.name))
            plt.xscale(&#39;log&#39;)
            plt.legend()
            title0 = &#39; &#39; + f_bin + &#39; : &#39; + str(int(son.bins[f_bin].range[0])) + &#39; - &#39; + str(
                int(son.bins[f_bin].range[1])) + &#39; Hz, &#39;
            title1 = &#39;Norm. Factors : &#39;
            title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
            plt.title(title0 + title1 + title2)

        else:
            print(&#39;invalid frequency bin&#39;)

    def combine_envelop(self, kind=&#39;signal&#39;, difference_factor=1, show_sounds=True, show_rejects=True, **kwargs):
        &#34;&#34;&#34;
        __ Multiple SoundPack Method __
        Combines the envelops of the Sounds contained in the SoundPack, Sounds having a too large difference factor
        from the average are rejected.

        :param kind: wich signal to use from :
        &#39;signal&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
        :param difference_factor: threshold to reject a sound from the combinaison, can be adjusted to reject
        or include more sounds.
        :param show_sounds: If True all the included Sounds are shown on the plot
        :param show_rejects: If True all the rejected Sounds are shown on the plot
        :param kwargs: Key word arguments to pass to the envelop plot.
        :return: None
        &#34;&#34;&#34;
        sounds = self.sounds
        sample_number = np.min([len(s1.signal.log_envelop()[0]) for s1 in sounds])

        if kind == &#39;signal&#39;:
            log_envelops = np.stack([s1.signal.normalize().log_envelop()[0][:sample_number] for s1 in sounds])
        elif kind in SP.bins.__dict__.keys():
            log_envelops = np.stack([s1.bins[kind].normalize().log_envelop()[0][:sample_number] for s1 in sounds])
        else:
            print(&#39;Wrong kind&#39;)

        average_log_envelop = np.mean(log_envelops, axis=0)
        means = np.tile(average_log_envelop, (len(sounds), 1))
        diffs = np.sum(np.abs(means - log_envelops), axis=1)
        diff = np.mean(diffs) * difference_factor

        good_sounds = np.array(sounds)[diffs &lt; diff]
        rejected_sounds = np.array(sounds)[diffs &gt; diff]
        average_log_envelop = np.mean(log_envelops[diffs &lt; diff], axis=0)
        norm_factors = np.array([s1.signal.normalize().norm_factor for s1 in good_sounds])

        if kind == &#39;signal&#39;:
            if show_sounds:
                for s1 in good_sounds[:-1]:
                    s1.signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;)
                sounds[-1].signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;, label=&#39;sounds&#39;)

            if show_rejects:
                if len(rejected_sounds) &gt; 1:
                    for s1 in rejected_sounds[:-1]:
                        s1.signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;)
                    rejected_sounds[-1].signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                                    label=&#39;rejected sounds&#39;)
                if len(rejected_sounds) == 1:
                    rejected_sounds[0].signal.normalize().plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                               label=&#39;rejected sounds&#39;)
            if len(good_sounds) &gt; 0:
                if &#39;label&#39; in kwargs.keys():
                    plt.plot(good_sounds[0].signal.log_envelop()[1][:len(average_log_envelop)], average_log_envelop,
                             **kwargs)
                else:
                    plt.plot(good_sounds[0].signal.log_envelop()[1][:len(average_log_envelop)], average_log_envelop,
                             label=&#39;average&#39;, color=&#39;k&#39;, **kwargs)

        else:
            if show_sounds:
                for s1 in good_sounds[:-1]:
                    s1.bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;)
                sounds[-1].bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;, label=&#39;sounds&#39;)

            if show_rejects:
                if len(rejected_sounds) &gt; 1:
                    for s2 in rejected_sounds[:-1]:
                        s2.bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;)
                    rejected_sounds[-1].bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                                        label=&#39;rejected sounds&#39;)
                if len(rejected_sounds) == 1:
                    rejected_sounds.bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                                    label=&#39;rejected sounds&#39;)

            plt.plot(good_sounds[0].signal.log_envelop()[1][:sample_number], average_log_envelop, color=&#39;k&#39;, **kwargs)

        plt.xlabel(&#39;time (s)&#39;)
        plt.ylabel(&#39;Amplitude&#39;)
        plt.legend()
        plt.xscale(&#39;log&#39;)
        print(&#39;Number of rejected sounds : &#39; + str(len(rejected_sounds)))
        print(&#39;Number of sounds included : &#39; + str(len(good_sounds)))
        print(&#39;Maximum normalisation factor : &#39; + str(np.around(np.max(norm_factors), 0)) + &#39;x&#39;)
        print(&#39;Minimum normalisation factor : &#39; + str(np.around(np.min(norm_factors), 0)) + &#39;x&#39;)

    def fundamentals(self):
        &#34;&#34;&#34;
        __ Multiple Soundpack Method __
        Displays the fundamentals of every sound in the SoundPack
        :return: None
        &#34;&#34;&#34;
        names = np.array([sound.name for sound in self.sounds])
        fundamentals = np.array([np.around(sound.fundamental, 1) for sound in self.sounds])
        key = np.argsort(fundamentals)
        table_data = [names[key], fundamentals[key]]

        table_data = np.array(table_data).transpose()

        print(tabulate(table_data, headers=[&#39;Name&#39;, &#39;Fundamental (Hz)&#39;]))

    def integral_plot(self, f_bin=&#39;all&#39;):
        &#34;&#34;&#34;
        Normalized cumulative bin power plot for the frequency bins

        __ Multiple SoundPack Method __
        Plots the cumulative integral plot of specified frequency bins
        see help(Plot.integral)

        f_bin: frequency bins to compare, Supported arguments are :
        &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
        &#34;&#34;&#34;

        if f_bin == &#39;all&#39;:
            # create a figure with 6 axes
            fig, axs = plt.subplots(3, 2, figsize=(12, 12))
            axs = axs.reshape(-1)

            for key, ax in zip(self.bin_strings, axs):
                plt.sca(ax)
                norm_factors = np.array([son.bins[key].normalize().norm_factor for son in self.sounds])
                for sound in self.sounds:
                    sound.bins[key].plot.integral(label=sound.name)
                plt.legend()
                title0 = &#39; &#39; + key + &#39; : &#39; + str(int(sound.bins[key].range[0])) + &#39; - &#39; + str(
                    int(sound.bins[key].range[1])) + &#39; Hz, &#39;
                title1 = &#39;Norm. Factors : &#39;
                title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
                plt.title(title0 + title1 + title2)
                plt.title(title0 + title1 + title2)
            plt.tight_layout()

        elif f_bin in self.bin_strings:
            fig, ax = plt.subplots(figsize=(6, 4))
            plt.sca(ax)
            norm_factors = np.array([son.bins[f_bin].normalize().norm_factor for son in self.sounds])
            for sound in self.sounds:
                sound.bins[f_bin].plot.integral(label=sound.name)
            plt.legend()
            title0 = &#39; &#39; + f_bin + &#39; : &#39; + str(int(sound.bins[f_bin].range[0])) + &#39; - &#39; + str(
                int(sound.bins[f_bin].range[1])) + &#39; Hz, &#39;
            title1 = &#39;Norm. Factors : &#39;
            title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
            plt.title(title0 + title1 + title2)

        else:
            print(&#39;invalid frequency bin&#39;)
            
    def bin_power_table(self):
        &#34;&#34;&#34;
        Displays a table with the signal power contained in every frequency bin
        
        The power is computed as the time integral of the signal
        &#34;&#34;&#34;
        # Bin power distribution table
        bin_strings = self.bin_strings
        integrals = []

        # for every sound in the SoundPack
        for sound in self.sounds:

            integral = []
            # for every frequency bin in the sound
            for f_bin in bin_strings:
                log_envelop, log_time = sound.bins[f_bin].normalize().log_envelop()
                integral.append(scipy.integrate.trapezoid(log_envelop, log_time))

            # a list of dict for every sound
            integrals.append(integral)

        # make the table
        table_data = np.array([list(bin_strings), *integrals]).transpose()
        sound_names = [sound.name for sound in self.sounds]

        print(&#39;___ Signal Power Frequency Bin Distribution ___ \n&#39;)
        print(tabulate(table_data, headers=[&#39;bin&#39;, *sound_names]))

    def bin_power_hist(self):
        &#34;&#34;&#34;
        Histogram of the frequency bin power for multiple sounds

        frequency bin power is computed as the integral of the bin envelop
        &#34;&#34;&#34;
        # Compute the bin powers
        bin_strings = self.bin_strings
        integrals = []

        # for every sound in the SoundPack
        for sound in self.sounds:

            integral = []
            # for every frequency bin in the sound
            for f_bin in bin_strings:
                log_envelop, log_time = sound.bins[f_bin].normalize().log_envelop()
                integral.append(scipy.integrate.trapezoid(log_envelop, log_time))

            # a list of dict for every sound
            integrals.append(integral)

        # create the bar plotting vectors
        fig, ax = plt.subplots(figsize=(6, 6))

        # make the bar plot
        n = len(self.sounds)
        width = 0.8 / n
        # get nice colors
        cmap = matplotlib.cm.get_cmap(&#39;Set2&#39;)
        for i, sound in enumerate(self.sounds):
            x = np.arange(i * width, len(bin_strings) + i * width)
            y = integrals[i]
            if n &lt; 8:
                color = cmap(i)
            else:
                color = None

            if i == n // 2:
                ax.bar(x, y, width=width, tick_label=list(bin_strings), label=sound.name, color=color)
            else:
                ax.bar(x, y, width=width, label=sound.name, color=color)
        plt.legend()

    &#34;&#34;&#34;
    Methods for dual SoundPacks
    &#34;&#34;&#34;

    def compare_peaks(self):
        &#34;&#34;&#34;
        Plot to compare the FFT peaks values of two sounds

        __ Dual SoundPack Method __
        Compares the peaks in the Fourier Transform of two Sounds,
        the peak with the highest difference is highlighted
        &#34;&#34;&#34;
        if self.kind == &#39;dual&#39;:
            son1 = self.sounds[0]
            son2 = self.sounds[1]
            index1 = np.where(son1.signal.fft_frequencies() &gt; self.SP.general.fft_range.value)[0][0]
            index2 = np.where(son2.signal.fft_frequencies() &gt; self.SP.general.fft_range.value)[0][0]

            # Get the peak data from the sounds
            peaks1 = son1.signal.peaks()
            peaks2 = son2.signal.peaks()
            freq1 = son1.signal.fft_frequencies()[:index1]
            freq2 = son2.signal.fft_frequencies()[:index2]
            fft1 = son1.signal.fft()[:index1]
            fft2 = son2.signal.fft()[:index2]

            peak_distance1 = np.mean([freq1[peaks1[i]] - freq1[peaks1[i + 1]] for i in range(len(peaks1) - 1)]) / 4
            peak_distance2 = np.mean([freq2[peaks2[i]] - freq2[peaks2[i + 1]] for i in range(len(peaks2) - 1)]) / 4
            peak_distance = np.abs(np.mean([peak_distance1, peak_distance2]))

            # Align  the two peak vectors
            new_peaks1 = []
            new_peaks2 = []
            for peak1 in peaks1:
                for peak2 in peaks2:
                    if np.abs(freq1[peak1] - freq2[peak2]) &lt; peak_distance:
                        new_peaks1.append(peak1)
                        new_peaks2.append(peak2)
            new_peaks1 = np.unique(np.array(new_peaks1))
            new_peaks2 = np.unique(np.array(new_peaks2))

            different_peaks1 = []
            different_peaks2 = []
            difference_threshold = 0.5
            while len(different_peaks1) &lt; 1:
                for peak1, peak2 in zip(new_peaks1, new_peaks2):
                    if np.abs(fft1[peak1] - fft2[peak2]) &gt; difference_threshold:
                        different_peaks1.append(peak1)
                        different_peaks2.append(peak2)
                difference_threshold -= 0.01

            # Plot the output
            plt.figure(figsize=(10, 6))
            plt.yscale(&#39;symlog&#39;, linthresh=10e-1)

            # Sound 1
            plt.plot(freq1, fft1, color=&#39;#919191&#39;, label=son1.name)
            plt.scatter(freq1[new_peaks1], fft1[new_peaks1], color=&#39;b&#39;, label=&#39;peaks&#39;)
            plt.scatter(freq1[different_peaks1], fft1[different_peaks1], color=&#39;g&#39;, label=&#39;diff peaks&#39;)
            annotation_string = &#39;Peaks with &#39; + str(np.around(difference_threshold, 2)) + &#39; difference&#39;
            plt.annotate(annotation_string, (freq1[different_peaks1[0]] + peak_distance / 2, fft1[different_peaks1[0]]))

            # Sound2
            plt.plot(freq2, -fft2, color=&#39;#3d3d3d&#39;, label=son2.name)
            plt.scatter(freq2[new_peaks2], -fft2[new_peaks2], color=&#39;b&#39;)
            plt.scatter(freq2[different_peaks2], -fft2[different_peaks2], color=&#39;g&#39;)
            plt.title(&#39;Fourier Transform Peak Analysis for &#39; + son1.name + &#39; and &#39; + son2.name)
            plt.grid(&#39;on&#39;)
            plt.legend()
        else:
            print(&#39;Unsupported for multiple sounds SoundPacks&#39;)

    def fft_mirror(self):
        &#34;&#34;&#34;
        Plot the Fourier Transforms of two sounds on opposed axis to compare the spectras

        __ Dual SoundPack Method __
        The fourier transforms are normalized between 0 and [-1, 1], the y scale is logarithmic
        :return: None
        &#34;&#34;&#34;
        if self.kind == &#39;dual&#39;:
            son1 = self.sounds[0]
            son2 = self.sounds[1]
            index = np.where(son1.signal.fft_frequencies() &gt; SP.general.fft_range.value)[0][0]

            plt.figure(figsize=(10, 6))
            plt.yscale(&#39;symlog&#39;)
            plt.grid(&#39;on&#39;)
            plt.plot(son1.signal.fft_frequencies()[:index], son1.signal.fft()[:index], label=son1.name)
            plt.plot(son2.signal.fft_frequencies()[:index], -son2.signal.fft()[:index], label=son2.name)
            plt.xlabel(&#39;Fréquence (Hz)&#39;)
            plt.ylabel(&#39;Amplitude&#39;)
            plt.title(&#39;Mirror Fourier Transform for &#39; + son1.name + &#39; and &#39; + son2.name)
            plt.legend()

        else:
            print(&#39;Unsupported for multiple sounds SoundPacks&#39;)

    def fft_diff(self, fraction=3, ticks=None):
        &#34;&#34;&#34;
        Plot the difference between the spectral distribution in the two sounds

        __ Dual SoundPack Method __
        Compare the Fourier Transform of two sounds by computing the differences of the octave bins heights.
        The two FTs are superimposed on the first plot to show differences
        The difference between the two FTs is plotted on the second plot

        :param fraction: octave fraction value used to compute the frequency bins A higher number will show
        a more precise comparison, but conclusions may be harder to draw.
        :param ticks:  If True the frequency bins intervals are used as X axis ticks
        :return: None
        &#34;&#34;&#34;
        if self.kind == &#39;dual&#39;:
            # Separate the sounds
            son1 = self.sounds[0]
            son2 = self.sounds[1]

            # Compute plotting bins
            x_values = utils.octave_values(fraction)
            hist_bins = utils.octave_histogram(fraction)
            bar_widths = np.array([hist_bins[i + 1] - hist_bins[i] for i in range(0, len(hist_bins) - 1)])

            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
            plot1 = ax1.hist(son1.signal.fft_bins(), utils.octave_histogram(fraction), color=&#39;blue&#39;, alpha=0.6,
                             label=son1.name)
            plot2 = ax1.hist(son2.signal.fft_bins(), utils.octave_histogram(fraction), color=&#39;orange&#39;, alpha=0.6,
                             label=son2.name)
            ax1.set_title(&#39;FT Histogram for &#39; + son1.name + &#39; and &#39; + son2.name)
            ax1.set_xscale(&#39;log&#39;)
            ax1.set_xlabel(&#39;Fréquence (Hz)&#39;)
            ax1.set_ylabel(&#39;Amplitude&#39;)
            ax1.grid(&#39;on&#39;)
            ax1.legend()

            diff = plot1[0] - plot2[0]
            n_index = np.where(diff &lt;= 0)[0]
            p_index = np.where(diff &gt;= 0)[0]

            # Negative difference corresponding to sound 2
            ax2.bar(x_values[n_index], diff[n_index], width=bar_widths[n_index], color=&#39;orange&#39;, alpha=0.6)
            # Positive difference corresponding to sound1
            ax2.bar(x_values[p_index], diff[p_index], width=bar_widths[p_index], color=&#39;blue&#39;, alpha=0.6)
            ax2.set_title(&#39;Difference &#39; + son1.name + &#39; - &#39; + son2.name)
            ax2.set_xscale(&#39;log&#39;)
            ax2.set_xlabel(&#39;Fréquence (Hz)&#39;)
            ax2.set_ylabel(&#39;&lt;- Son 2 : Son 1 -&gt;&#39;)
            ax2.grid(&#39;on&#39;)

            if ticks == &#39;bins&#39;:
                labels = [label for label in self.SP.bins.__dict__ if label != &#39;name&#39;]
                labels.append(&#39;brillance&#39;)
                x = [param.value for param in self.SP.bins.__dict__.values() if param != &#39;bins&#39;]
                x.append(11250)
                x_formatter = ticker.FixedFormatter(labels)
                x_locator = ticker.FixedLocator(x)
                ax1.xaxis.set_major_locator(x_locator)
                ax1.xaxis.set_major_formatter(x_formatter)
                ax1.tick_params(axis=&#34;x&#34;, labelrotation=90)
                ax2.xaxis.set_major_locator(x_locator)
                ax2.xaxis.set_major_formatter(x_formatter)
                ax2.tick_params(axis=&#34;x&#34;, labelrotation=90)

        else:
            print(&#39;Unsupported for multiple sounds SoundPacks&#39;)

    def integral_compare(self, f_bin=&#39;all&#39;):
        &#34;&#34;&#34;
          Cumulative bin envelop integral comparison for two signals

          __ Dual SoundPack Method __
          Plots the cumulative integral plot of specified frequency bins
          and their difference as surfaces

          f_bin: frequency bins to compare, Supported arguments are :
          &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
          &#34;&#34;&#34;

        # Case when plotting all the frequency bins
        if f_bin == &#39;all&#39;:
            fig, axs = plt.subplots(3, 2, figsize=(16, 16))
            axs = axs.reshape(-1)

            self.bin_strings = self.sounds[0].bins.keys()
            bins1 = self.sounds[0].bins.values()
            bins2 = self.sounds[1].bins.values()

            for signal1, signal2, bin_string, ax in zip(bins1, bins2, self.bin_strings, axs):
                log_envelop1, log_time1 = signal1.normalize().log_envelop()
                log_envelop2, log_time2 = signal2.normalize().log_envelop()
                integ = scipy.integrate.trapezoid

                integral1 = np.array([integ(log_envelop1[:i], log_time1[:i]) for i in np.arange(2, len(log_envelop1), 1)])
                integral2 = np.array([integ(log_envelop2[:i], log_time2[:i]) for i in np.arange(2, len(log_envelop2), 1)])
                time1 = log_time1[2:len(log_time1):1]
                time2 = log_time2[2:len(log_time2):1]

                int_index = np.min([integral1.shape[0], integral2.shape[0]])
                ax.fill_between(time1, integral1, label=self.sounds[0].name, alpha=0.4)
                ax.fill_between(time2, -integral2, label=self.sounds[1].name, alpha=0.4)
                ax.fill_between(time2, integral1 - integral2, color=&#39;g&#39;, label=&#39;int diff&#39;, alpha=0.6)

                ax.set_xlabel(&#39;time (s)&#39;)
                ax.set_ylabel(&#39;cummulative power&#39;)
                ax.set_xscale(&#39;log&#39;)
                ax.set_title(bin_string)
                ax.legend()
                ax.grid(&#39;on&#39;)
            plt.tight_layout()

        elif f_bin in self.bin_strings:
            fig, ax = plt.subplots(figsize=(8, 6))
            signal1 = self.sounds[0].bins[f_bin]
            signal2 = self.sounds[1].bins[f_bin]
            log_envelop1, log_time1 = signal1.normalize().log_envelop()
            log_envelop2, log_time2 = signal2.normalize().log_envelop()
            integ = scipy.integrate.trapezoid

            integral1 = np.array([integ(log_envelop1[:i], log_time1[:i]) for i in np.arange(2, len(log_envelop1), 1)])
            integral2 = np.array([integ(log_envelop2[:i], log_time2[:i]) for i in np.arange(2, len(log_envelop2), 1)])
            time1 = log_time1[2:len(log_time1):1]
            time2 = log_time2[2:len(log_time2):1]

            int_index = np.min([integral1.shape[0], integral2.shape[0]])
            ax.fill_between(time1, integral1, label=self.sounds[0].name, alpha=0.4)
            ax.fill_between(time2, -integral2, label=self.sounds[1].name, alpha=0.4)
            ax.fill_between(time2, integral1 - integral2, color=&#39;g&#39;, label=&#39;int diff&#39;, alpha=0.6)

            ax.set_xlabel(&#39;time (s)&#39;)
            ax.set_ylabel(&#39;cummulative power&#39;)
            ax.set_xscale(&#39;log&#39;)
            ax.set_title(f_bin)
            ax.legend(loc=&#39;upper left&#39;)
            ax.grid(&#39;on&#39;)

        else:
            print(&#39;invalid frequency bin&#39;)

    def coherence_plot(self):
        &#34;&#34;&#34;
        __ Dual SoundPack Method __
        computes and plots the coherence between the time signal of two Sounds
        :return: None
        &#34;&#34;&#34;
        if self.kind == &#39;dual&#39;:
            f, C = sig.coherence(self.sounds[0].signal.signal, self.sounds[1].signal.signal, self.sounds[0].signal.sr)
            plt.plot(f, C, color=&#39;b&#39;)
            plt.yscale(&#39;log&#39;)
            plt.xlabel(&#39;Fréquence (Hz)&#39;)
            plt.ylabel(&#39;Coherence [0, 1]&#39;)
            title = &#39;Cohérence entre les sons &#39; + self.sounds[0].name + &#39; et &#39; + self.sounds[1].name
            plt.title(title)
        else:
            print(&#39;Unsupported for multiple sounds SoundPacks&#39;)


class Sound(object):
    &#34;&#34;&#34;
    A class to store audio signals obtained from a sound and compare them
    &#34;&#34;&#34;

    def __init__(self, file, name=&#39;&#39;, fundamental=None, SoundParams=None):
        &#34;&#34;&#34;
        Creates a Sound instance from a .wav file, name as a string and fundamental frequency
        value can be user specified.
        :param file: file path to the .wav file
        :param name: Sound instance name to use in plot legend and titles
        :param fundamental: Fundamental frequency value if None the value is estimated
        from the FFT (see `Signal.fundamental`).
        :param SoundParams: SoundParameters to use in the Sound instance
        &#34;&#34;&#34;
        # create a reference of the parameters
        if SoundParams is None:
            self.SP = SP
        else:
            self.SP = SoundParams

        if type(file) == str:
            # Load the soundfile using librosa
            signal, sr = librosa.load(file)
            self.file = file

        elif type(file) == tuple:
            signal, sr = file

        # create a Signal class from the signal and sample rate
        self.raw_signal = Signal(signal, sr, self.SP)

        # Allow user specified fundamental
        self.fundamental = fundamental
        self.name = name

    def condition(self, verbose=True, return_self=False):
        &#34;&#34;&#34;
        A method conditioning the Sound instance.
        - Trimming to just before the onset
        - Filtering the noise
        :param verbose: if True problem with trimming and filtering are reported
        :param return_self: If True the method returns the conditioned Sound instance
        :return: a conditioned Sound instance if `return_self = True`
        &#34;&#34;&#34;
        self.trim_signal(verbose=verbose)
        self.filter_noise(verbose=verbose)
        self.bin_divide()
        if self.fundamental is None:
            self.fundamental = self.signal.fundamental()
        self.plot = self.signal.plot
        if return_self:
            return self

    def use_raw_signal(self, normalized=False):
        &#34;&#34;&#34;
        Assigns the raw signal to the `signal` attribute of the Sound instance to
        analyze it
        :param normalized: if True, the raw signal is first normalized
        :return: None
        &#34;&#34;&#34;
        if normalized:
            self.signal = self.raw_signal.normalize()
        else:
            self.signal = self.raw_signal

    def bin_divide(self):
        &#34;&#34;&#34;
        Calls the `.make_freq_bins` method of the signal to create the signals associated
        to the frequency bins. The bins are all stored in the `.bin` attribute and also as
        their names (Ex: `Sound.mid` contains the mid signal).
        :return: None
        &#34;&#34;&#34;
        &#34;&#34;&#34; a method to divide the main signal into frequency bins&#34;&#34;&#34;
        # divide in frequency bins
        self.bins = self.signal.make_freq_bins()
        # unpack the bins
        self.bass, self.mid, self.highmid, self.uppermid, self.presence, self.brillance = self.bins.values()

    def filter_noise(self, verbose=True):
        &#34;&#34;&#34;
        Filters the noise in the signal attribute
        :param verbose: if True problem are printed to the terminal
        :return: None
        &#34;&#34;&#34;
        # filter the noise in the Signal class
        self.signal = self.trimmed_signal.filter_noise(verbose=verbose)

    def trim_signal(self, verbose=True):
        &#34;&#34;&#34;
        A method to trim the signal to a specific time before the onset. The time value
        can be changed in the SoundParameters.
        :param verbose: if True problems encountered are printed to the terminal
        :return: None
        &#34;&#34;&#34;
        # Trim the signal in the signal class
        self.trimmed_signal = self.raw_signal.trim_onset(verbose=verbose)

    def listen_freq_bins(self):
        &#34;&#34;&#34;
        Method to listen to all the frequency bins of a sound

        The bins signals are obtained by filtering the sound signal
        with band pass filters.

        See guitarsounds.parameters.sound_parameters().bins.info() for the
        frequency bin intervals.
        &#34;&#34;&#34;
        for key in self.bins.keys():
            print(key)
            self.bins[key].normalize().listen()

    def plot_freq_bins(self, bins=None):
        &#34;&#34;&#34;
        Method to plot all the frequency bins logarithmic envelops of a sound

        The parameter `bins` allows choosing specific frequency bins to plot
        By default the function plots all the bins
        Supported bins arguments are :
        &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;

        Example :
        `Sound.plot_freq_bins(bins=[&#39;all])` plots all the frequency bins
        `Sound.plot_freq_bins(bins=[&#39;bass&#39;, &#39;mid&#39;])` plots the bass and mid bins
        &#34;&#34;&#34;
        try:
            value = bins[0]
            if value == &#39;all&#39;:
                bins = self.bins.keys()
        except TypeError:
            if bins is None:
                bins = self.bins.keys()

        for key in bins:
            lab = key + &#39; : &#39; + str(int(self.bins[key].range[0])) + &#39; - &#39; + str(int(self.bins[key].range[1])) + &#39; Hz&#39;
            self.bins[key].old_plot(&#39;log envelop&#39;, label=lab)

        plt.xscale(&#39;log&#39;)
        plt.yscale(&#39;log&#39;)
        plt.legend(fontsize=&#34;x-small&#34;)  # using a named size

    def peak_damping(self):
        &#34;&#34;&#34;
        Prints a table with peak damping values and peak frequency values

        The peaks are found with the `signal.peaks()` function and the damping
        values are computed with the half power bandwith method.
        &#34;&#34;&#34;
        peak_indexes = self.signal.peaks()
        frequencies = self.signal.fft_frequencies()[peak_indexes]
        damping = self.signal.peak_damping()
        table_data = np.array([frequencies, np.array(damping) * 100]).transpose()
        print(tabulate(table_data, headers=[&#39;Frequency (Hz)&#39;, &#39;Damping ratio (%)&#39;]))

    def bin_hist(self):
        &#34;&#34;&#34;
        Histogram of the frequency bin power

        frequency bin power is computed as the integral of the bin envelop.
        See guitarsounds.parameters.sound_parameters().bins.info() for the
        frequency bin intervals.
        &#34;&#34;&#34;
        # Compute the bin powers
        bin_strings = list(self.bins.keys())
        integral = []

        for f_bin in bin_strings:
            log_envelop, log_time = self.bins[f_bin].normalize().log_envelop()
            integral.append(scipy.integrate.trapezoid(log_envelop, log_time))

        # create the bar plotting vectors
        fig, ax = plt.subplots(figsize=(6, 6))

        x = np.arange(0, len(bin_strings))
        y = integral
        ax.bar(x, y, tick_label=list(bin_strings))


class Signal(object):
    &#34;&#34;&#34;
    A Class to do computations on an audio signal.

    The signal is never changed in the class, when transformations are made, a new instance is returned.
    &#34;&#34;&#34;

    def __init__(self, signal, sr, SoundParam, freq_range=None):
        &#34;&#34;&#34; Create a Signal class from a vector of samples and a sample rate&#34;&#34;&#34;
        self.SP = SoundParam
        self.onset = None
        self.signal = signal
        self.sr = sr
        self.range = freq_range
        self.trimmed = None
        self.noise = None
        self.plot = Plot()
        self.plot.parent = self

    def time(self):
        &#34;&#34;&#34;
        Returns the time vector associated to the signal
        :return: numpy array corresponding to the time values of the signal samples in seconds
        &#34;&#34;&#34;
        return np.linspace(0, len(self.signal) * (1 / self.sr), len(self.signal))

    def listen(self):
        &#34;&#34;&#34;
        Method to listen the sound signal in a Jupyter Notebook

        Listening to the sounds imported in the analysis tool allows the
        user to validate if the sound was well trimmed and filtered

        A temporary file is created, the IPython display Audio function is
        called on it and then the file is removed
        &#34;&#34;&#34;
        file = &#39;temp.wav&#39;
        write(file, self.signal, self.sr)
        ipd.display(ipd.Audio(file))
        os.remove(file)

    def old_plot(self, kind, **kwargs):
        &#34;&#34;&#34;
        Convenience function for the different signal plots

        Calls the function corresponding to Plot.kind()
        See help(guitarsounds.analysis.Plot) for info on the different plots
        &#34;&#34;&#34;

        self.plot.method_dict[kind](**kwargs)

    def fft(self):
        &#34;&#34;&#34;
        Computes the Fast Fourier Transform of the signal and returns the vector.
        :return: Fast Fourier Transform amplitude values in a numpy array
        &#34;&#34;&#34;
        fft = np.fft.fft(self.signal)
        fft = np.abs(fft[:int(len(fft) // 2)])  # Only the symmetric of the absolute value
        return fft / np.max(fft)

    def peaks(self, max_freq=None, height=False, result=False):
        &#34;&#34;&#34;
        Computes the harmonic peaks indexes from the FFT of the signal
        :param max_freq: Supply a max frequency value overiding the one in guitarsounds_parameters
        :param height: if True the height threshold is returned to be used in the &#39;peaks&#39; plot
        :param result: if True the Scipy peak finding results dictionary is returned
        :return: peak indexes
        &#34;&#34;&#34;
        # Replace None by the default value
        if max_freq is None:
            max_freq = self.SP.general.fft_range.value

        # Get the fft and fft frequencies from the signal
        fft, fft_freq = self.fft(), self.fft_frequencies()

        # Find the max index
        max_index = np.where(fft_freq &gt;= max_freq)[0][0]

        # Find an approximation of the distance between peaks, this only works for harmonic signals
        peak_distance = np.argmax(fft) // 2

        # Maximum of the signal in a small region on both ends
        fft_max_start = np.max(fft[:peak_distance])
        fft_max_end = np.max(fft[max_index - peak_distance:max_index])

        # Build the curve below the peaks but above the noise
        exponents = np.linspace(np.log10(fft_max_start), np.log10(fft_max_end), max_index)
        intersect = 10 ** exponents[peak_distance]
        diff_start = fft_max_start - intersect  # offset by a small distance so that the first max is not a peak
        min_height = 10 ** np.linspace(np.log10(fft_max_start + diff_start), np.log10(fft_max_end), max_index)

        first_peak_indexes, _ = sig.find_peaks(fft[:max_index], height=min_height, distance=peak_distance)

        number_of_peaks = len(first_peak_indexes)
        if number_of_peaks &gt; 0:
            average_len = int(max_index / number_of_peaks) * 3
        else:
            average_len = int(max_index / 3)

        if average_len % 2 == 0:
            average_len += 1

        average_fft = sig.savgol_filter(fft[:max_index], average_len, 1, mode=&#39;mirror&#39;) * 1.9
        min_freq_index = np.where(fft_freq &gt;= 70)[0][0]
        average_fft[:min_freq_index] = 1

        peak_indexes, res = sig.find_peaks(fft[:max_index], height=average_fft, distance=min_freq_index)

        # Remove noisy peaks at the low frequencies
        while fft[peak_indexes[0]] &lt; 5e-2:
            peak_indexes = np.delete(peak_indexes, 0)
        while fft[peak_indexes[-1]] &lt; 1e-4:
            peak_indexes = np.delete(peak_indexes, -1)

        if not height and not result:
            return peak_indexes
        elif height:
            return peak_indexes, average_fft
        elif result:
            return peak_indexes, res
        elif height and result:
            return peak_indexes, height, res

    def time_damping(self):
        &#34;&#34;&#34;
        Computes the time wise damping ratio of the signal by fitting a negative exponential curve
        to the Signal envelop and computing the ratio with the Signal fundamental frequency.
        :return: The damping ratio, a scalar.
        &#34;&#34;&#34;
        # Get the envelop data
        envelop_time = self.normalize().envelop_time()
        envelop = self.normalize().envelop()

        # First point is the maximum because e^-kt is stricly decreasing
        first_index = np.argmax(envelop)

        # The second point is the first point where the signal crosses the lower_threshold line
        second_point_thresh = self.SP.damping.lower_threshold.value
        try:
            second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh)[0]
        except IndexError:
            second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh * 2)[0]

        # Function to compute the residual for the exponential curve fit
        def residual_function(zeta_w, t, s):
            &#34;&#34;&#34;
            Function computing the residual to curve fit a negative exponential to the signal envelop
            :param zeta_w: zeta*omega constant
            :param t: time vector
            :param s: signal
            :return: residual
            &#34;&#34;&#34;
            return np.exp(zeta_w[0] * t) - s

        zeta_guess = [-0.5]

        result = scipy.optimize.least_squares(residual_function, zeta_guess,
                                              args=(envelop_time[first_index:second_index],
                                                    envelop[first_index:second_index]))
        # Get the zeta*omega constant
        zeta_omega = result.x[0]

        # Compute the fundamental frequency in radiants of the signal
        wd = 2 * np.pi * self.fundamental()
        return -zeta_omega / wd

    def peak_damping(self):
        &#34;&#34;&#34;
        Computes the frequency wise damping with the half bandwidth method on the Fourier Transform peaks
        :return: an array containing the peak damping values
        &#34;&#34;&#34;
        zetas = []
        fft_freqs = self.fft_frequencies()
        fft = self.fft()[:len(fft_freqs)]
        for peak in self.peaks():
            peak_frequency = fft_freqs[peak]
            peak_height = fft[peak]
            root_height = peak_height / np.sqrt(2)
            frequency_roots = scipy.interpolate.InterpolatedUnivariateSpline(fft_freqs, fft - root_height).roots()
            sorted_roots_indexes = np.argsort(np.abs(frequency_roots - peak_frequency))
            w2, w1 = frequency_roots[sorted_roots_indexes[:2]]
            w1, w2 = np.sort([w1, w2])
            zeta = (w2 - w1) / (2 * peak_frequency)
            zetas.append(zeta)
        return np.array(zetas)

    def fundamental(self):
        &#34;&#34;&#34;
        Returns the fundamental approximated by the first peak of the fft
        :return: fundamental value (Hz)
        &#34;&#34;&#34;
        index = self.peaks()[0]
        fundamental = self.fft_frequencies()[index]
        return fundamental

    def cavity_peak(self):
        &#34;&#34;&#34;
        Finds the Hemlotz cavity frequency index from the Fourier Transform by searching for a peak in the expected
        range (80 - 100 Hz), if the fundamental is too close to the expected Hemlotz frequency a comment
        is printed and None is returned.
        :return: If successful the cavity peak index
        &#34;&#34;&#34;
        first_index = np.where(self.fft_frequencies() &gt;= 80)[0][0]
        second_index = np.where(self.fft_frequencies() &gt;= 110)[0][0]
        cavity_peak = np.argmax(self.fft()[first_index:second_index]) + first_index
        if self.fundamental() == self.fft_frequencies()[cavity_peak]:
            print(&#39;Cavity peak is obscured by the fundamental&#39;)
        else:
            return cavity_peak

    def cavity_frequency(self):
        &#34;&#34;&#34;
        Finds the hemlotz cavity frequency from the Fourier Transform by searching for a peak in the expected
        range (80 - 100 Hz), if the fundamental is too close to the expected hemlotz frequency a comment
        is printed and None is returned.
        :return: If successful, the cavity peak frequency
        &#34;&#34;&#34;
        first_index = np.where(self.fft_frequencies() &gt;= 80)[0][0]
        second_index = np.where(self.fft_frequencies() &gt;= 110)[0][0]
        cavity_peak = np.argmax(self.fft()[first_index:second_index]) + first_index
        if self.fundamental() == self.fft_frequencies()[cavity_peak]:
            print(&#39;Cavity peak is obscured by the fundamental&#39;)
            return 0
        else:
            return self.fft_frequencies()[cavity_peak]

    def fft_frequencies(self):
        &#34;&#34;&#34;
        Computes the frequency vector associated to the Signal Fourier Transform
        :return: an array containing the frequency values.
        &#34;&#34;&#34;
        fft = self.fft()
        fft_frequencies = np.fft.fftfreq(len(fft) * 2, 1 / self.sr)  # Frequencies corresponding to the bins
        return fft_frequencies[:len(fft)]

    def fft_bins(self):
        &#34;&#34;&#34;
        Transforms the Fourier Transform signal into a statistic distribution.
        Occurences of each frequency varies from 0 to 100 according to their
        amplitude.
        :return : a list containing the frequency occurences.
        &#34;&#34;&#34;

        # Make the FT values integers
        fft_integers = [int(np.around(sample * 100, 0)) for sample in self.fft()]

        # Create a list of the frequency occurrences in the signal
        occurrences = []
        for freq, count in zip(self.fft_frequencies(), fft_integers):
            occurrences.append([freq] * count)

        # flatten the list
        return [item for sublist in occurrences for item in sublist]

    def envelop(self):
        &#34;&#34;&#34;
        Method calculating the amplitude envelope of a signal as a
        maximum of the absolute value of the signal.
        :return: Amplitude envelop of the signal
        &#34;&#34;&#34;
        # Get the hop length
        hop_length = self.SP.envelop.hop_length.value

        # Compute the envelop
        envelop = np.array(
            [np.max(np.abs(self.signal[i:i + self.SP.envelop.frame_size.value])) for i in
             range(0, len(self.signal), hop_length)])

        envelop = np.insert(envelop, 0, 0)
        return envelop

    def envelop_time(self):
        &#34;&#34;&#34;
        Method calculating the time vector associated to a signal envelop
        :return: Time vector associated to the signal envelop
        &#34;&#34;&#34;
        # Get the number of frames from the signal envelop
        frames = range(len(self.envelop()))
        # Return the envelop frames computed with Librosa
        return librosa.frames_to_time(frames, hop_length=self.SP.envelop.hop_length.value)

    def log_envelop(self):
        &#34;&#34;&#34;
        Computes the logarithmic scale envelop of the signal.
        The width of the samples increases exponentially so that
        the envelop appears having a constant window width on
        an X axis logarithmic scale.
        :return: The log envelop and the time vector associated in a tuple
        &#34;&#34;&#34;
        if self.onset is None:
            onset = np.argmax(self.signal)
        else:
            onset = self.onset

        start_time = self.SP.log_envelop.start_time.value
        while start_time &gt; (onset / self.sr):
            start_time /= 10.

        start_exponent = int(np.log10(start_time))  # closest 10^x value for smooth graph

        if self.SP.log_envelop.min_window.value is None:
            min_window = 15 ** (start_exponent + 4)
            if min_window &lt; 15:  # Value should at least be 10
                min_window = 15
        else:
            min_window = self.SP.log_envelop.min_window.value

        # initial values
        current_exponent = start_exponent
        current_time = 10 ** current_exponent  # start time on log scale
        index = int(current_time * self.sr)  # Start at the specified time
        window = min_window  # number of samples per window
        overlap = window // 2
        log_envelop = []
        log_envelop_time = [0]  # First value for comparison

        while index + window &lt;= len(self.signal):

            while log_envelop_time[-1] &lt; 10 ** (current_exponent + 1):
                if (index + window) &lt; len(self.signal):
                    log_envelop.append(np.max(self.signal[index:index + window]))
                    log_envelop_time.append(self.time()[index])
                    index += overlap
                else:
                    break

            if window * 10 &lt; self.SP.log_envelop.max_window.value:
                window = window * 10
            else:
                window = self.SP.log_envelop.max_window.value

            overlap = window // 2
            current_exponent += 1

        # remove the value where t=0 so the log scale does not break
        log_envelop_time.remove(0)

        return np.array(log_envelop), np.array(log_envelop_time)

    def find_onset(self, verbose=True):
        &#34;&#34;&#34;
        Finds the onset as an increase in more of 50% with the maximum normalized value above 0.5
        :param verbose: Prints a warning if the algorithm does not converge
        :return: the index of the onset in the signal
        &#34;&#34;&#34;
        # Index corresponding to the onset time interval
        window_index = np.ceil(self.SP.onset.onset_time.value * self.sr).astype(int)
        # Use the normalized signal to compare against a fixed value
        onset_signal = self.normalize()
        overlap = window_index // 2  # overlap for algorithm progression
        # Initial values
        increase = 0
        i = 0
        broke = False
        while increase &lt;= 0.5:
            signal_min = np.min(np.abs(onset_signal.signal[i:i + window_index]))
            signal_max = np.max(np.abs(onset_signal.signal[i:i + window_index]))
            if (signal_max &gt; 0.5) and (signal_min != 0):
                increase = signal_max / signal_min
            else:
                increase = 0
            i += overlap
            if i + window_index &gt; len(self.signal):
                if verbose:
                    print(&#39;Onset detection did not converge \n&#39;)
                    print(&#39;Approximating onset with signal max value \n&#39;)
                    broke = True
                    break
        if broke:
            return np.argmax(self.signal)
        else:
            return np.argmax(np.abs(self.signal[i:i + window_index])) + i

    def trim_onset(self, verbose=True):
        &#34;&#34;&#34;
        Trim the signal at the onset (max) minus the delay in milliseconds as
        Specified in the SoundParameters
        :param : verbose if False the warning comments are not displayed
        :return : a trimmed signal with a noise attribute
        &#34;&#34;&#34;
        # nb of samples to keep before the onset
        delay_samples = int((self.SP.onset.onset_delay.value / 1000) * self.sr)
        onset = self.find_onset(verbose=verbose)  # find the onset

        if onset &gt; delay_samples:  # To make sure the index is positive
            trimmed_signal = Signal(self.signal[onset - delay_samples:], self.sr, self.SP)
            trimmed_signal.noise = self.signal[:onset - delay_samples]
            trimmed_signal.trimmed = True
            trimmed_signal.onset = np.argmax(trimmed_signal.signal)
            return trimmed_signal

        else:
            if verbose:
                print(&#39;Signal is too short to be trimmed before onset.&#39;)
                print(&#39;&#39;)
            self.trimmed = False
            return self

    def trim_time(self, time_length):
        &#34;&#34;&#34;
        Trims the signal to the specified length and returns a new Signal instance.
        :param time_length: desired length of the new signal in seconds.
        :return: A trimmed Signal
        &#34;&#34;&#34;
        max_index = int(time_length * self.sr)
        time_trimmed_signal = Signal(self.signal[:max_index], self.sr, self.SP)
        time_trimmed_signal.time_length = time_length
        return time_trimmed_signal

    def filter_noise(self, verbose=True):
        &#34;&#34;&#34;
        Method filtering the noise from the recorded signal and returning a filtered signal.
        If the signal was not trimmed it is trimmed in place then filtered.
        If the signal can not be trimmed it can&#39;t be filtered and the original signal is returned
        :return : A Signal instance, filtered if possible.
        &#34;&#34;&#34;
        try:
            return Signal(reduce_noise(audio_clip=self.signal, noise_clip=self.noise), self.sr, self.SP)
        except AttributeError:
            if self.trimmed is False:
                if verbose:
                    print(&#39;Not sufficient noise in the raw signal, unable to filter.&#39;)
                    print(&#39;&#39;)
                return self

    def normalize(self):
        &#34;&#34;&#34;
        Normalizes the signal to [-1, 1] and returns the normalised instance.
        :return : A normalized signal
        &#34;&#34;&#34;
        factor = np.max(np.abs(self.signal))
        normalised_signal = Signal((self.signal / factor), self.sr, self.SP)
        normalised_signal.norm_factor = (1 / factor)
        return normalised_signal

    def make_freq_bins(self):
        &#34;&#34;&#34;
        Method to divide a signal in frequency bins using butterworth filters
        bins are passed as a dict, default values are :
        - bass &lt; 100 Hz
        - mid = 100 - 700 Hz
        - highmid = 700 - 2000 Hz
        - uppermid = 2000 - 4000 Hz
        - presence = 4000 - 6000 Hz
        - brillance &gt; 6000 Hz
        :return : A dictionary with the divided signal as values and bin names as keys
        &#34;&#34;&#34;

        bins = self.SP.bins.__dict__

        bass_filter = sig.butter(12, bins[&#34;bass&#34;].value, &#39;lp&#39;, fs=self.sr, output=&#39;sos&#39;)
        mid_filter = sig.butter(12, [bins[&#34;bass&#34;].value, bins[&#39;mid&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
        himid_filter = sig.butter(12, [bins[&#34;mid&#34;].value, bins[&#39;highmid&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
        upmid_filter = sig.butter(12, [bins[&#34;highmid&#34;].value, bins[&#39;uppermid&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
        pres_filter = sig.butter(12, [bins[&#34;uppermid&#34;].value, bins[&#39;presence&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
        bril_filter = sig.butter(12, bins[&#39;presence&#39;].value, &#39;hp&#39;, fs=self.sr, output=&#39;sos&#39;)

        return {
            &#34;bass&#34;: Signal(sig.sosfilt(bass_filter, self.signal), self.sr, self.SP,
                           freq_range=[0, bins[&#34;bass&#34;].value]),
            &#34;mid&#34;: Signal(sig.sosfilt(mid_filter, self.signal), self.sr, self.SP,
                          freq_range=[bins[&#34;bass&#34;].value, bins[&#34;mid&#34;].value]),
            &#34;highmid&#34;: Signal(sig.sosfilt(himid_filter, self.signal), self.sr, self.SP,
                              freq_range=[bins[&#34;mid&#34;].value, bins[&#34;highmid&#34;].value]),
            &#34;uppermid&#34;: Signal(sig.sosfilt(upmid_filter, self.signal), self.sr, self.SP,
                               freq_range=[bins[&#34;highmid&#34;].value, bins[&#34;uppermid&#34;].value]),
            &#34;presence&#34;: Signal(sig.sosfilt(pres_filter, self.signal), self.sr, self.SP,
                               freq_range=[bins[&#39;uppermid&#39;].value, bins[&#34;presence&#34;].value]),
            &#34;brillance&#34;: Signal(sig.sosfilt(bril_filter, self.signal), self.sr, self.SP,
                                freq_range=[bins[&#34;presence&#34;].value, max(self.fft_frequencies())])}

    def timbre(self):
        &#34;&#34;&#34;
        A method computing the timbral attributes of the signal

        This method returns timbral attributes &#34;Brightness&#34;, &#34;Depth&#34;, &#34;Boominess&#34;, &#34;Sharpness&#34; and &#34;Warmth&#34;.
        They are obtained trough linear regression with a model trained with regular sounds.
        More information :
        Andy Pearce, Mark Plumbley, Saeid, S., Brookes, T., Mason, R., &amp; Wang, W. (2019).
        Release of timbral characterisation tools for semantically annotating non-musical content.pdf
        (Rapport No. AC-WP5-SURREY-D5.8). AudioCommons. Repéré à :
        https://www.audiocommons.org/assets/files/AC-WP5-SURREY-D5.8%20Release%20of%20timbral
        %20characterisation%20tools%20for%20semantically%20annotating%20non-musical%20content.pdf
        :return: A dictionary with timbral attributes and their values
        &#34;&#34;&#34;
        # Save the signal in a temporary file
        self.save_wav(&#39;temp&#39;)
        # Compute the timbre dict from the temp file
        timbre = timbral_extractor(&#39;temp.wav&#39;, verbose=False)
        # remove reverb and roughness and hardness attributes
        timbre = {key: timbre[key] for key in timbre if key not in [&#39;reverb&#39;, &#39;roughness&#39;, &#39;hardness&#39;]}
        # Remove the temp file
        os.remove(&#39;temp.wav&#39;)
        return timbre

    def save_wav(self, name, path=&#39;&#39;):
        &#34;&#34;&#34;
        Create a soundfile from a signal
        :param name: the name of the saved file
        :param path: the path were the &#39;.wav&#39; file is saved
        &#34;&#34;&#34;
        write(path + name + &#34;.wav&#34;, self.signal, self.sr)


class Plot(object):
    &#34;&#34;&#34;
        A class to handle all the plotting functions of the Signal and to allow a nice call signature :
        Signal.plot.envelop()

        Supported plots are :
        &#39;signal&#39;, &#39;envelop&#39;, &#39;log envelop&#39;, &#39;fft&#39;, &#39;fft hist&#39;, &#39;peaks&#39;, &#39;peak damping&#39;, &#39;time damping&#39;,
        &#39;timbre&#39;, &#39;integral
    &#34;&#34;&#34;

    # Illegal plot key word arguments
    illegal_kwargs = [&#39;max_time&#39;, &#39;n&#39;, &#39;ticks&#39;, &#39;normalize&#39;, &#39;inverse&#39;, &#39;peak_height&#39;, &#39;fill&#39;]

    def __init__(self):
        # define the parent attribute
        self.parent = None

        # dictonary with methods and key words
        self.method_dict = {&#39;signal&#39;: self.signal,
                            &#39;envelop&#39;: self.envelop,
                            &#39;log envelop&#39;: self.log_envelop,
                            &#39;fft&#39;: self.fft,
                            &#39;fft hist&#39;: self.fft_hist,
                            &#39;peaks&#39;: self.peaks,
                            &#39;peak damping&#39;: self.peak_damping,
                            &#39;time damping&#39;: self.time_damping,
                            &#39;timbre&#39;: self.timbre,
                            &#39;integral&#39;: self.integral, }

    def sanitize_kwargs(self, kwargs):
        &#34;&#34;&#34;
        Remove illegal key words to supply the key word arguments to matplotlib
        :param kwargs:
        :return: sanitized kwargs
        &#34;&#34;&#34;
        return {i: kwargs[i] for i in kwargs if i not in self.illegal_kwargs}

    def set_bin_ticks(self):
        &#34;&#34;&#34;
        Applies the frequency bin ticks to the current plot
        :param kwargs:
        :return:
        &#34;&#34;&#34;
        labels = [label for label in self.parent.SP.bins.__dict__ if label != &#39;name&#39;]
        labels.append(&#39;brillance&#39;)
        x = [param.value for param in self.parent.SP.bins.__dict__.values() if param != &#39;bins&#39;]
        x.append(11250)
        x_formatter = ticker.FixedFormatter(labels)
        x_locator = ticker.FixedLocator(x)
        ax = plt.gca()
        ax.xaxis.set_major_locator(x_locator)
        ax.xaxis.set_major_formatter(x_formatter)
        ax.tick_params(axis=&#34;x&#34;, labelrotation=90)

    def signal(self, **kwargs):
        &#34;&#34;&#34;
            Plots the time varying real signal as amplitude vs time.
            &#34;&#34;&#34;
        plot_kwargs = self.sanitize_kwargs(kwargs)
        plt.plot(self.parent.time(), self.parent.signal, alpha=0.6, **plot_kwargs)
        plt.xlabel(&#39;time (s)&#39;)
        plt.ylabel(&#39;amplitude&#39;)
        plt.grid(&#39;on&#39;)

    def envelop(self, **kwargs):
        &#34;&#34;&#34;
            Plots the envelop of the signal as amplitude vs time.
            &#34;&#34;&#34;
        plot_kwargs = self.sanitize_kwargs(kwargs)
        plt.plot(self.parent.envelop_time(), self.parent.envelop(), **plot_kwargs)
        plt.xlabel(&#34;time (s)&#34;)
        plt.ylabel(&#34;amplitude&#34;)
        plt.grid(&#39;on&#39;)

    def log_envelop(self, **kwargs):
        &#34;&#34;&#34;
            Plots the signal envelop with logarithmic window widths on a logarithmic x axis scale.
            &#34;&#34;&#34;
        plot_kwargs = self.sanitize_kwargs(kwargs)
        log_envelop, log_envelop_time = self.parent.log_envelop()

        if (&#39;max_time&#39; in kwargs.keys()) and (kwargs[&#39;max_time&#39;] &lt; log_envelop_time[-1]):
            max_index = np.nonzero(log_envelop_time &gt;= kwargs[&#39;max_time&#39;])[0][0]
        else:
            max_index = len(log_envelop_time)

        plt.plot(log_envelop_time[:max_index], log_envelop[:max_index], **plot_kwargs)
        plt.xlabel(&#34;time (s)&#34;)
        plt.ylabel(&#34;amplitude&#34;)
        plt.xscale(&#39;log&#39;)
        plt.grid(&#39;on&#39;)

    def fft(self, **kwargs):
        &#34;&#34;&#34;
            Plots the Fourier Transform of the Signal.

            If `ticks = &#39;bins&#39;` is supplied in the keyword arguments, the frequency ticks are replaced
            with the frequency bin values.
            &#34;&#34;&#34;

        plot_kwargs = self.sanitize_kwargs(kwargs)

        # find the index corresponding to the fft range
        result = np.where(self.parent.fft_frequencies() &gt;= self.parent.SP.general.fft_range.value)[0]
        if len(result) == 0:
            last_index = -1
        else:
            last_index = result[0]

        plt.plot(self.parent.fft_frequencies()[:last_index], self.parent.fft()[:last_index], **plot_kwargs)
        plt.xlabel(&#34;frequency&#34;),
        plt.ylabel(&#34;amplitude&#34;),
        plt.yscale(&#39;log&#39;)
        plt.grid(&#39;on&#39;)

        if &#39;ticks&#39; in kwargs and kwargs[&#39;ticks&#39;] == &#39;bins&#39;:
            self.set_bin_ticks()

    def fft_hist(self, **kwargs):
        &#34;&#34;&#34;
            Plots the octave based Fourier Transform Histogram.
            Both axes are on a log scale.

            If `ticks = &#39;bins&#39;` is supplied in the keyword arguments, the frequency ticks are replaced
            with the frequency bin values
            &#34;&#34;&#34;

        plot_kwargs = self.sanitize_kwargs(kwargs)

        # Histogram of frequency values occurences in octave bins
        plt.hist(self.parent.fft_bins(), utils.octave_histogram(self.parent.SP.general.octave_fraction.value),
                 alpha=0.7, **plot_kwargs)
        plt.xlabel(&#39;Fréquence (Hz)&#39;)
        plt.ylabel(&#39;Amplitude&#39;)
        plt.xscale(&#39;log&#39;)
        plt.yscale(&#39;log&#39;)
        plt.grid(&#39;on&#39;)

        if &#39;ticks&#39; in kwargs and kwargs[&#39;ticks&#39;] == &#39;bins&#39;:
            self.set_bin_ticks()

    def peaks(self, **kwargs):
        &#34;&#34;&#34;
            Plots the Fourier Transform of the Signal, with the peaks detected with the `Signal.peaks()` method.

            If `peak_height = True` is supplied in the keyword arguments the computed height threshold is
            shown on the plot.
            &#34;&#34;&#34;

        plot_kwargs = self.sanitize_kwargs(kwargs)

        fft_freqs = self.parent.fft_frequencies()
        fft = self.parent.fft()
        max_index = np.where(fft_freqs &gt;= self.parent.SP.general.fft_range.value)[0][0]
        peak_indexes, height = self.parent.peaks(height=True)
        plt.xlabel(&#39;Fréquence (Hz)&#39;)
        plt.ylabel(&#39;Amplitude&#39;)
        plt.yscale(&#39;log&#39;)
        plt.grid(&#39;on&#39;)

        if &#39;color&#39; not in plot_kwargs.keys():
            plot_kwargs[&#39;color&#39;] = &#39;k&#39;
        plt.plot(fft_freqs[:max_index], fft[:max_index], **plot_kwargs)
        plt.scatter(fft_freqs[peak_indexes], fft[peak_indexes], color=&#39;r&#39;)
        if (&#39;peak_height&#39; in kwargs.keys()) and (kwargs[&#39;peak_height&#39;]):
            plt.plot(fft_freqs[:max_index], height, color=&#39;r&#39;)

    def peak_damping(self, **kwargs):
        &#34;&#34;&#34;
            Plots the frequency vs damping scatter of the damping ratio computed from the
            Fourier Transform peak shapes. A polynomial curve fit is added to help visualisation.

            Supported key word arguments are :

            `n=5` : The order of the fitted polynomial curve, default is 5,
            if the supplied value is too high, it will be reduced until the number of peaks
            is sufficient to fit the polynomial.

            `inverse=True` : Default value is True, if False, the damping ratio is shown instead
            of its inverse.

            `normalize=False` : Default value is False, if True the damping values are normalized
            from 0 to 1, to help analyze results and compare Sounds.

            `ticks=None` : Default value is None, if `ticks=&#39;bins&#39;` the x axis ticks are replaced with
            frequency bin values.
            &#34;&#34;&#34;
        plot_kwargs = self.sanitize_kwargs(kwargs)
        # Get the damping ratio and peak frequencies
        if &#39;inverse&#39; in kwargs.keys() and kwargs[&#39;inverse&#39;] is False:
            zetas = np.array(self.parent.peak_damping())
            ylabel = r&#39;Damping $\zeta$&#39;
        else:
            zetas = 1 / np.array(self.parent.peak_damping())
            ylabel = r&#39;Inverse Damping $1/\zeta$&#39;

        peak_freqs = self.parent.fft_frequencies()[self.parent.peaks()]

        # If a polynomial order is supplied assign it, if not default is 5
        if &#39;n&#39; in kwargs.keys():
            n = kwargs[&#39;n&#39;]
        else:
            n = 5

        # If labels are supplied the default color are used
        if &#39;label&#39; in plot_kwargs:
            plot_kwargs[&#39;color&#39;] = None
            plot2_kwargs = plot_kwargs.copy()
            plot2_kwargs[&#39;label&#39;] = None

        # If not black and red are used
        else:
            plot_kwargs[&#39;color&#39;] = &#39;r&#39;
            plot2_kwargs = plot_kwargs.copy()
            plot2_kwargs[&#39;color&#39;] = &#39;k&#39;

        if &#39;normalize&#39; in kwargs.keys() and kwargs[&#39;normalize&#39;]:
            zetas = np.array(zetas) / np.array(zetas).max()

        plt.scatter(peak_freqs, zetas, **plot_kwargs)
        fun = utils.nth_order_polynomial_fit(n, peak_freqs, zetas)
        freq = np.linspace(peak_freqs[0], peak_freqs[-1], 100)
        plt.plot(freq, fun(freq), **plot2_kwargs)
        plt.grid(&#39;on&#39;)
        plt.title(&#39;Frequency vs Damping Factor with Order &#39; + str(n))
        plt.xlabel(&#39;Frequency (Hz)&#39;)
        plt.ylabel(ylabel)

        if &#39;ticks&#39; in kwargs and kwargs[&#39;ticks&#39;] == &#39;bins&#39;:
            self.set_bin_ticks()

    def time_damping(self, **kwargs):
        &#34;&#34;&#34;
            Shows the signal envelop with the fitted negative exponential curve used to determine the
            time damping ratio of the signal.
            &#34;&#34;&#34;
        plot_kwargs = self.sanitize_kwargs(kwargs)
        # Get the envelop data
        envelop_time = self.parent.normalize().envelop_time()
        envelop = self.parent.normalize().envelop()

        # First point is the maximum because e^-kt is stricly decreasing
        first_index = np.argmax(envelop)

        # The second point is the first point where the signal crosses the lower_threshold line
        second_point_thresh = self.parent.SP.damping.lower_threshold.value

        try:
            second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh)[0]
        except IndexError:
            second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh * 2)[0]

        # Function to compute the residual for the exponential curve fit
        def residual_function(zeta_w, t, s):
            return np.exp(zeta_w[0] * t) - s

        zeta_guess = [-0.5]

        result = scipy.optimize.least_squares(residual_function, zeta_guess,
                                              args=(envelop_time[first_index:second_index],
                                                    envelop[first_index:second_index]))
        # Get the zeta*omega constant
        zeta_omega = result.x[0]

        # Compute the fundamental frequency in radiants of the signal
        wd = 2 * np.pi * self.parent.fundamental()

        # Plot the two points used for the regression
        plt.scatter(envelop_time[[first_index, second_index]], envelop[[first_index, second_index]], color=&#39;r&#39;)

        # get the current ax
        ax = plt.gca()

        # Plot the damping curve
        ax.plot(envelop_time[first_index:second_index],
                np.exp(zeta_omega * envelop_time[first_index:second_index]), c=&#39;k&#39;)

        plt.sca(ax)
        self.parent.normalize().plot.envelop(**plot_kwargs)

        if &#39;label&#39; not in plot_kwargs.keys():
            ax.legend([&#39;damping curve&#39;, &#39;signal envelop&#39;])

        title = &#39;Zeta : &#39; + str(np.around(-zeta_omega / wd, 5)) + &#39; Fundamental &#39; + \
                str(np.around(self.parent.fundamental(), 0)) + &#39;Hz&#39;
        plt.title(title)

    def timbre(self, **kwargs):
        &#34;&#34;&#34;
            A polar plot of the timbral attributes of the signal

            See help(guitarsounds.analysis.Signal.timbre) for more info about the timbral attributes
            &#34;&#34;&#34;

        plot_kwargs = self.sanitize_kwargs(kwargs)

        fig = plt.gcf()
        if not fig.axes:  # case when the figure is empty
            ax = fig.add_subplot(projection=&#39;polar&#39;)

        elif plt.gca().name == &#39;polar&#39;:  # if the current ax is polar
            ax = plt.gca()

        timbre = self.parent.timbre()  # compute timbral attributes
        categories = list(timbre.keys())  # get the timbral categories
        values = list(timbre.values())  # get the timbral values
        N = len(values)  # Number of values
        values += values[:1]  # append the first value to the end to close the loop
        angles = [n / float(N) * 2 * np.pi for n in range(N)]  # N equidistant angles
        angles += angles[:1]  # append the first value at the end
        ax.plot(angles, values, lw=2, **plot_kwargs)
        if &#39;fill&#39; in kwargs and kwargs[&#39;fill&#39;]:
            ax.fill(angles, values)

        ax.set_yticks([])
        ax.set_yticklabels([])
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(categories)
        ax.xaxis.set_tick_params(pad=18)
        ax.set_theta_zero_location(&#39;S&#39;)

    def integral(self, **kwargs):
        &#34;&#34;&#34;
        Cumulative integral plot of the normalized signal log envelop

        Represents the power distribution variation in time for the signal.
        This is a plot of the function $F(x)$ such as :

        $ F(x) = \int_0^x e(x) dx $

        Where e(x) is the signal envelop.
        &#34;&#34;&#34;
        # sanitize the kwargs
        plot_kwargs = self.sanitize_kwargs(kwargs)

        # Compute log envelop and log time
        log_envelop, log_time = self.parent.normalize().log_envelop()

        # define integrating function
        integ = scipy.integrate.trapezoid

        # compute the cumulative integral
        integral = [integ(log_envelop[:i], log_time[:i]) for i in np.arange(2, len(log_envelop), 1)]

        # plot the integral
        plt.plot(log_time[2:], integral, **plot_kwargs)

        # Add labels and scale
        plt.xlabel(&#39;time (s)&#39;)
        plt.ylabel(&#39;cummulative power&#39;)
        plt.xscale(&#39;log&#39;)
        plt.grid(&#39;on&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="guitarsounds.analysis.SP"><code class="name">var <span class="ident">SP</span></code></dt>
<dd>
<div class="desc"><p>Classes</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="guitarsounds.analysis.Plot"><code class="flex name class">
<span>class <span class="ident">Plot</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class to handle all the plotting functions of the Signal and to allow a nice call signature :
Signal.plot.envelop()</p>
<p>Supported plots are :
'signal', 'envelop', 'log envelop', 'fft', 'fft hist', 'peaks', 'peak damping', 'time damping',
'timbre', 'integral</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plot(object):
    &#34;&#34;&#34;
        A class to handle all the plotting functions of the Signal and to allow a nice call signature :
        Signal.plot.envelop()

        Supported plots are :
        &#39;signal&#39;, &#39;envelop&#39;, &#39;log envelop&#39;, &#39;fft&#39;, &#39;fft hist&#39;, &#39;peaks&#39;, &#39;peak damping&#39;, &#39;time damping&#39;,
        &#39;timbre&#39;, &#39;integral
    &#34;&#34;&#34;

    # Illegal plot key word arguments
    illegal_kwargs = [&#39;max_time&#39;, &#39;n&#39;, &#39;ticks&#39;, &#39;normalize&#39;, &#39;inverse&#39;, &#39;peak_height&#39;, &#39;fill&#39;]

    def __init__(self):
        # define the parent attribute
        self.parent = None

        # dictonary with methods and key words
        self.method_dict = {&#39;signal&#39;: self.signal,
                            &#39;envelop&#39;: self.envelop,
                            &#39;log envelop&#39;: self.log_envelop,
                            &#39;fft&#39;: self.fft,
                            &#39;fft hist&#39;: self.fft_hist,
                            &#39;peaks&#39;: self.peaks,
                            &#39;peak damping&#39;: self.peak_damping,
                            &#39;time damping&#39;: self.time_damping,
                            &#39;timbre&#39;: self.timbre,
                            &#39;integral&#39;: self.integral, }

    def sanitize_kwargs(self, kwargs):
        &#34;&#34;&#34;
        Remove illegal key words to supply the key word arguments to matplotlib
        :param kwargs:
        :return: sanitized kwargs
        &#34;&#34;&#34;
        return {i: kwargs[i] for i in kwargs if i not in self.illegal_kwargs}

    def set_bin_ticks(self):
        &#34;&#34;&#34;
        Applies the frequency bin ticks to the current plot
        :param kwargs:
        :return:
        &#34;&#34;&#34;
        labels = [label for label in self.parent.SP.bins.__dict__ if label != &#39;name&#39;]
        labels.append(&#39;brillance&#39;)
        x = [param.value for param in self.parent.SP.bins.__dict__.values() if param != &#39;bins&#39;]
        x.append(11250)
        x_formatter = ticker.FixedFormatter(labels)
        x_locator = ticker.FixedLocator(x)
        ax = plt.gca()
        ax.xaxis.set_major_locator(x_locator)
        ax.xaxis.set_major_formatter(x_formatter)
        ax.tick_params(axis=&#34;x&#34;, labelrotation=90)

    def signal(self, **kwargs):
        &#34;&#34;&#34;
            Plots the time varying real signal as amplitude vs time.
            &#34;&#34;&#34;
        plot_kwargs = self.sanitize_kwargs(kwargs)
        plt.plot(self.parent.time(), self.parent.signal, alpha=0.6, **plot_kwargs)
        plt.xlabel(&#39;time (s)&#39;)
        plt.ylabel(&#39;amplitude&#39;)
        plt.grid(&#39;on&#39;)

    def envelop(self, **kwargs):
        &#34;&#34;&#34;
            Plots the envelop of the signal as amplitude vs time.
            &#34;&#34;&#34;
        plot_kwargs = self.sanitize_kwargs(kwargs)
        plt.plot(self.parent.envelop_time(), self.parent.envelop(), **plot_kwargs)
        plt.xlabel(&#34;time (s)&#34;)
        plt.ylabel(&#34;amplitude&#34;)
        plt.grid(&#39;on&#39;)

    def log_envelop(self, **kwargs):
        &#34;&#34;&#34;
            Plots the signal envelop with logarithmic window widths on a logarithmic x axis scale.
            &#34;&#34;&#34;
        plot_kwargs = self.sanitize_kwargs(kwargs)
        log_envelop, log_envelop_time = self.parent.log_envelop()

        if (&#39;max_time&#39; in kwargs.keys()) and (kwargs[&#39;max_time&#39;] &lt; log_envelop_time[-1]):
            max_index = np.nonzero(log_envelop_time &gt;= kwargs[&#39;max_time&#39;])[0][0]
        else:
            max_index = len(log_envelop_time)

        plt.plot(log_envelop_time[:max_index], log_envelop[:max_index], **plot_kwargs)
        plt.xlabel(&#34;time (s)&#34;)
        plt.ylabel(&#34;amplitude&#34;)
        plt.xscale(&#39;log&#39;)
        plt.grid(&#39;on&#39;)

    def fft(self, **kwargs):
        &#34;&#34;&#34;
            Plots the Fourier Transform of the Signal.

            If `ticks = &#39;bins&#39;` is supplied in the keyword arguments, the frequency ticks are replaced
            with the frequency bin values.
            &#34;&#34;&#34;

        plot_kwargs = self.sanitize_kwargs(kwargs)

        # find the index corresponding to the fft range
        result = np.where(self.parent.fft_frequencies() &gt;= self.parent.SP.general.fft_range.value)[0]
        if len(result) == 0:
            last_index = -1
        else:
            last_index = result[0]

        plt.plot(self.parent.fft_frequencies()[:last_index], self.parent.fft()[:last_index], **plot_kwargs)
        plt.xlabel(&#34;frequency&#34;),
        plt.ylabel(&#34;amplitude&#34;),
        plt.yscale(&#39;log&#39;)
        plt.grid(&#39;on&#39;)

        if &#39;ticks&#39; in kwargs and kwargs[&#39;ticks&#39;] == &#39;bins&#39;:
            self.set_bin_ticks()

    def fft_hist(self, **kwargs):
        &#34;&#34;&#34;
            Plots the octave based Fourier Transform Histogram.
            Both axes are on a log scale.

            If `ticks = &#39;bins&#39;` is supplied in the keyword arguments, the frequency ticks are replaced
            with the frequency bin values
            &#34;&#34;&#34;

        plot_kwargs = self.sanitize_kwargs(kwargs)

        # Histogram of frequency values occurences in octave bins
        plt.hist(self.parent.fft_bins(), utils.octave_histogram(self.parent.SP.general.octave_fraction.value),
                 alpha=0.7, **plot_kwargs)
        plt.xlabel(&#39;Fréquence (Hz)&#39;)
        plt.ylabel(&#39;Amplitude&#39;)
        plt.xscale(&#39;log&#39;)
        plt.yscale(&#39;log&#39;)
        plt.grid(&#39;on&#39;)

        if &#39;ticks&#39; in kwargs and kwargs[&#39;ticks&#39;] == &#39;bins&#39;:
            self.set_bin_ticks()

    def peaks(self, **kwargs):
        &#34;&#34;&#34;
            Plots the Fourier Transform of the Signal, with the peaks detected with the `Signal.peaks()` method.

            If `peak_height = True` is supplied in the keyword arguments the computed height threshold is
            shown on the plot.
            &#34;&#34;&#34;

        plot_kwargs = self.sanitize_kwargs(kwargs)

        fft_freqs = self.parent.fft_frequencies()
        fft = self.parent.fft()
        max_index = np.where(fft_freqs &gt;= self.parent.SP.general.fft_range.value)[0][0]
        peak_indexes, height = self.parent.peaks(height=True)
        plt.xlabel(&#39;Fréquence (Hz)&#39;)
        plt.ylabel(&#39;Amplitude&#39;)
        plt.yscale(&#39;log&#39;)
        plt.grid(&#39;on&#39;)

        if &#39;color&#39; not in plot_kwargs.keys():
            plot_kwargs[&#39;color&#39;] = &#39;k&#39;
        plt.plot(fft_freqs[:max_index], fft[:max_index], **plot_kwargs)
        plt.scatter(fft_freqs[peak_indexes], fft[peak_indexes], color=&#39;r&#39;)
        if (&#39;peak_height&#39; in kwargs.keys()) and (kwargs[&#39;peak_height&#39;]):
            plt.plot(fft_freqs[:max_index], height, color=&#39;r&#39;)

    def peak_damping(self, **kwargs):
        &#34;&#34;&#34;
            Plots the frequency vs damping scatter of the damping ratio computed from the
            Fourier Transform peak shapes. A polynomial curve fit is added to help visualisation.

            Supported key word arguments are :

            `n=5` : The order of the fitted polynomial curve, default is 5,
            if the supplied value is too high, it will be reduced until the number of peaks
            is sufficient to fit the polynomial.

            `inverse=True` : Default value is True, if False, the damping ratio is shown instead
            of its inverse.

            `normalize=False` : Default value is False, if True the damping values are normalized
            from 0 to 1, to help analyze results and compare Sounds.

            `ticks=None` : Default value is None, if `ticks=&#39;bins&#39;` the x axis ticks are replaced with
            frequency bin values.
            &#34;&#34;&#34;
        plot_kwargs = self.sanitize_kwargs(kwargs)
        # Get the damping ratio and peak frequencies
        if &#39;inverse&#39; in kwargs.keys() and kwargs[&#39;inverse&#39;] is False:
            zetas = np.array(self.parent.peak_damping())
            ylabel = r&#39;Damping $\zeta$&#39;
        else:
            zetas = 1 / np.array(self.parent.peak_damping())
            ylabel = r&#39;Inverse Damping $1/\zeta$&#39;

        peak_freqs = self.parent.fft_frequencies()[self.parent.peaks()]

        # If a polynomial order is supplied assign it, if not default is 5
        if &#39;n&#39; in kwargs.keys():
            n = kwargs[&#39;n&#39;]
        else:
            n = 5

        # If labels are supplied the default color are used
        if &#39;label&#39; in plot_kwargs:
            plot_kwargs[&#39;color&#39;] = None
            plot2_kwargs = plot_kwargs.copy()
            plot2_kwargs[&#39;label&#39;] = None

        # If not black and red are used
        else:
            plot_kwargs[&#39;color&#39;] = &#39;r&#39;
            plot2_kwargs = plot_kwargs.copy()
            plot2_kwargs[&#39;color&#39;] = &#39;k&#39;

        if &#39;normalize&#39; in kwargs.keys() and kwargs[&#39;normalize&#39;]:
            zetas = np.array(zetas) / np.array(zetas).max()

        plt.scatter(peak_freqs, zetas, **plot_kwargs)
        fun = utils.nth_order_polynomial_fit(n, peak_freqs, zetas)
        freq = np.linspace(peak_freqs[0], peak_freqs[-1], 100)
        plt.plot(freq, fun(freq), **plot2_kwargs)
        plt.grid(&#39;on&#39;)
        plt.title(&#39;Frequency vs Damping Factor with Order &#39; + str(n))
        plt.xlabel(&#39;Frequency (Hz)&#39;)
        plt.ylabel(ylabel)

        if &#39;ticks&#39; in kwargs and kwargs[&#39;ticks&#39;] == &#39;bins&#39;:
            self.set_bin_ticks()

    def time_damping(self, **kwargs):
        &#34;&#34;&#34;
            Shows the signal envelop with the fitted negative exponential curve used to determine the
            time damping ratio of the signal.
            &#34;&#34;&#34;
        plot_kwargs = self.sanitize_kwargs(kwargs)
        # Get the envelop data
        envelop_time = self.parent.normalize().envelop_time()
        envelop = self.parent.normalize().envelop()

        # First point is the maximum because e^-kt is stricly decreasing
        first_index = np.argmax(envelop)

        # The second point is the first point where the signal crosses the lower_threshold line
        second_point_thresh = self.parent.SP.damping.lower_threshold.value

        try:
            second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh)[0]
        except IndexError:
            second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh * 2)[0]

        # Function to compute the residual for the exponential curve fit
        def residual_function(zeta_w, t, s):
            return np.exp(zeta_w[0] * t) - s

        zeta_guess = [-0.5]

        result = scipy.optimize.least_squares(residual_function, zeta_guess,
                                              args=(envelop_time[first_index:second_index],
                                                    envelop[first_index:second_index]))
        # Get the zeta*omega constant
        zeta_omega = result.x[0]

        # Compute the fundamental frequency in radiants of the signal
        wd = 2 * np.pi * self.parent.fundamental()

        # Plot the two points used for the regression
        plt.scatter(envelop_time[[first_index, second_index]], envelop[[first_index, second_index]], color=&#39;r&#39;)

        # get the current ax
        ax = plt.gca()

        # Plot the damping curve
        ax.plot(envelop_time[first_index:second_index],
                np.exp(zeta_omega * envelop_time[first_index:second_index]), c=&#39;k&#39;)

        plt.sca(ax)
        self.parent.normalize().plot.envelop(**plot_kwargs)

        if &#39;label&#39; not in plot_kwargs.keys():
            ax.legend([&#39;damping curve&#39;, &#39;signal envelop&#39;])

        title = &#39;Zeta : &#39; + str(np.around(-zeta_omega / wd, 5)) + &#39; Fundamental &#39; + \
                str(np.around(self.parent.fundamental(), 0)) + &#39;Hz&#39;
        plt.title(title)

    def timbre(self, **kwargs):
        &#34;&#34;&#34;
            A polar plot of the timbral attributes of the signal

            See help(guitarsounds.analysis.Signal.timbre) for more info about the timbral attributes
            &#34;&#34;&#34;

        plot_kwargs = self.sanitize_kwargs(kwargs)

        fig = plt.gcf()
        if not fig.axes:  # case when the figure is empty
            ax = fig.add_subplot(projection=&#39;polar&#39;)

        elif plt.gca().name == &#39;polar&#39;:  # if the current ax is polar
            ax = plt.gca()

        timbre = self.parent.timbre()  # compute timbral attributes
        categories = list(timbre.keys())  # get the timbral categories
        values = list(timbre.values())  # get the timbral values
        N = len(values)  # Number of values
        values += values[:1]  # append the first value to the end to close the loop
        angles = [n / float(N) * 2 * np.pi for n in range(N)]  # N equidistant angles
        angles += angles[:1]  # append the first value at the end
        ax.plot(angles, values, lw=2, **plot_kwargs)
        if &#39;fill&#39; in kwargs and kwargs[&#39;fill&#39;]:
            ax.fill(angles, values)

        ax.set_yticks([])
        ax.set_yticklabels([])
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(categories)
        ax.xaxis.set_tick_params(pad=18)
        ax.set_theta_zero_location(&#39;S&#39;)

    def integral(self, **kwargs):
        &#34;&#34;&#34;
        Cumulative integral plot of the normalized signal log envelop

        Represents the power distribution variation in time for the signal.
        This is a plot of the function $F(x)$ such as :

        $ F(x) = \int_0^x e(x) dx $

        Where e(x) is the signal envelop.
        &#34;&#34;&#34;
        # sanitize the kwargs
        plot_kwargs = self.sanitize_kwargs(kwargs)

        # Compute log envelop and log time
        log_envelop, log_time = self.parent.normalize().log_envelop()

        # define integrating function
        integ = scipy.integrate.trapezoid

        # compute the cumulative integral
        integral = [integ(log_envelop[:i], log_time[:i]) for i in np.arange(2, len(log_envelop), 1)]

        # plot the integral
        plt.plot(log_time[2:], integral, **plot_kwargs)

        # Add labels and scale
        plt.xlabel(&#39;time (s)&#39;)
        plt.ylabel(&#39;cummulative power&#39;)
        plt.xscale(&#39;log&#39;)
        plt.grid(&#39;on&#39;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="guitarsounds.analysis.Plot.illegal_kwargs"><code class="name">var <span class="ident">illegal_kwargs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="guitarsounds.analysis.Plot.envelop"><code class="name flex">
<span>def <span class="ident">envelop</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the envelop of the signal as amplitude vs time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def envelop(self, **kwargs):
    &#34;&#34;&#34;
        Plots the envelop of the signal as amplitude vs time.
        &#34;&#34;&#34;
    plot_kwargs = self.sanitize_kwargs(kwargs)
    plt.plot(self.parent.envelop_time(), self.parent.envelop(), **plot_kwargs)
    plt.xlabel(&#34;time (s)&#34;)
    plt.ylabel(&#34;amplitude&#34;)
    plt.grid(&#39;on&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.fft"><code class="name flex">
<span>def <span class="ident">fft</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the Fourier Transform of the Signal.</p>
<p>If <code>ticks = 'bins'</code> is supplied in the keyword arguments, the frequency ticks are replaced
with the frequency bin values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fft(self, **kwargs):
    &#34;&#34;&#34;
        Plots the Fourier Transform of the Signal.

        If `ticks = &#39;bins&#39;` is supplied in the keyword arguments, the frequency ticks are replaced
        with the frequency bin values.
        &#34;&#34;&#34;

    plot_kwargs = self.sanitize_kwargs(kwargs)

    # find the index corresponding to the fft range
    result = np.where(self.parent.fft_frequencies() &gt;= self.parent.SP.general.fft_range.value)[0]
    if len(result) == 0:
        last_index = -1
    else:
        last_index = result[0]

    plt.plot(self.parent.fft_frequencies()[:last_index], self.parent.fft()[:last_index], **plot_kwargs)
    plt.xlabel(&#34;frequency&#34;),
    plt.ylabel(&#34;amplitude&#34;),
    plt.yscale(&#39;log&#39;)
    plt.grid(&#39;on&#39;)

    if &#39;ticks&#39; in kwargs and kwargs[&#39;ticks&#39;] == &#39;bins&#39;:
        self.set_bin_ticks()</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.fft_hist"><code class="name flex">
<span>def <span class="ident">fft_hist</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the octave based Fourier Transform Histogram.
Both axes are on a log scale.</p>
<p>If <code>ticks = 'bins'</code> is supplied in the keyword arguments, the frequency ticks are replaced
with the frequency bin values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fft_hist(self, **kwargs):
    &#34;&#34;&#34;
        Plots the octave based Fourier Transform Histogram.
        Both axes are on a log scale.

        If `ticks = &#39;bins&#39;` is supplied in the keyword arguments, the frequency ticks are replaced
        with the frequency bin values
        &#34;&#34;&#34;

    plot_kwargs = self.sanitize_kwargs(kwargs)

    # Histogram of frequency values occurences in octave bins
    plt.hist(self.parent.fft_bins(), utils.octave_histogram(self.parent.SP.general.octave_fraction.value),
             alpha=0.7, **plot_kwargs)
    plt.xlabel(&#39;Fréquence (Hz)&#39;)
    plt.ylabel(&#39;Amplitude&#39;)
    plt.xscale(&#39;log&#39;)
    plt.yscale(&#39;log&#39;)
    plt.grid(&#39;on&#39;)

    if &#39;ticks&#39; in kwargs and kwargs[&#39;ticks&#39;] == &#39;bins&#39;:
        self.set_bin_ticks()</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.integral"><code class="name flex">
<span>def <span class="ident">integral</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Cumulative integral plot of the normalized signal log envelop</p>
<p>Represents the power distribution variation in time for the signal.
This is a plot of the function $F(x)$ such as :</p>
<p>$ F(x) = \int_0^x e(x) dx $</p>
<p>Where e(x) is the signal envelop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integral(self, **kwargs):
    &#34;&#34;&#34;
    Cumulative integral plot of the normalized signal log envelop

    Represents the power distribution variation in time for the signal.
    This is a plot of the function $F(x)$ such as :

    $ F(x) = \int_0^x e(x) dx $

    Where e(x) is the signal envelop.
    &#34;&#34;&#34;
    # sanitize the kwargs
    plot_kwargs = self.sanitize_kwargs(kwargs)

    # Compute log envelop and log time
    log_envelop, log_time = self.parent.normalize().log_envelop()

    # define integrating function
    integ = scipy.integrate.trapezoid

    # compute the cumulative integral
    integral = [integ(log_envelop[:i], log_time[:i]) for i in np.arange(2, len(log_envelop), 1)]

    # plot the integral
    plt.plot(log_time[2:], integral, **plot_kwargs)

    # Add labels and scale
    plt.xlabel(&#39;time (s)&#39;)
    plt.ylabel(&#39;cummulative power&#39;)
    plt.xscale(&#39;log&#39;)
    plt.grid(&#39;on&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.log_envelop"><code class="name flex">
<span>def <span class="ident">log_envelop</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the signal envelop with logarithmic window widths on a logarithmic x axis scale.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_envelop(self, **kwargs):
    &#34;&#34;&#34;
        Plots the signal envelop with logarithmic window widths on a logarithmic x axis scale.
        &#34;&#34;&#34;
    plot_kwargs = self.sanitize_kwargs(kwargs)
    log_envelop, log_envelop_time = self.parent.log_envelop()

    if (&#39;max_time&#39; in kwargs.keys()) and (kwargs[&#39;max_time&#39;] &lt; log_envelop_time[-1]):
        max_index = np.nonzero(log_envelop_time &gt;= kwargs[&#39;max_time&#39;])[0][0]
    else:
        max_index = len(log_envelop_time)

    plt.plot(log_envelop_time[:max_index], log_envelop[:max_index], **plot_kwargs)
    plt.xlabel(&#34;time (s)&#34;)
    plt.ylabel(&#34;amplitude&#34;)
    plt.xscale(&#39;log&#39;)
    plt.grid(&#39;on&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.peak_damping"><code class="name flex">
<span>def <span class="ident">peak_damping</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the frequency vs damping scatter of the damping ratio computed from the
Fourier Transform peak shapes. A polynomial curve fit is added to help visualisation.</p>
<p>Supported key word arguments are :</p>
<p><code>n=5</code> : The order of the fitted polynomial curve, default is 5,
if the supplied value is too high, it will be reduced until the number of peaks
is sufficient to fit the polynomial.</p>
<p><code>inverse=True</code> : Default value is True, if False, the damping ratio is shown instead
of its inverse.</p>
<p><code>normalize=False</code> : Default value is False, if True the damping values are normalized
from 0 to 1, to help analyze results and compare Sounds.</p>
<p><code>ticks=None</code> : Default value is None, if <code>ticks='bins'</code> the x axis ticks are replaced with
frequency bin values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_damping(self, **kwargs):
    &#34;&#34;&#34;
        Plots the frequency vs damping scatter of the damping ratio computed from the
        Fourier Transform peak shapes. A polynomial curve fit is added to help visualisation.

        Supported key word arguments are :

        `n=5` : The order of the fitted polynomial curve, default is 5,
        if the supplied value is too high, it will be reduced until the number of peaks
        is sufficient to fit the polynomial.

        `inverse=True` : Default value is True, if False, the damping ratio is shown instead
        of its inverse.

        `normalize=False` : Default value is False, if True the damping values are normalized
        from 0 to 1, to help analyze results and compare Sounds.

        `ticks=None` : Default value is None, if `ticks=&#39;bins&#39;` the x axis ticks are replaced with
        frequency bin values.
        &#34;&#34;&#34;
    plot_kwargs = self.sanitize_kwargs(kwargs)
    # Get the damping ratio and peak frequencies
    if &#39;inverse&#39; in kwargs.keys() and kwargs[&#39;inverse&#39;] is False:
        zetas = np.array(self.parent.peak_damping())
        ylabel = r&#39;Damping $\zeta$&#39;
    else:
        zetas = 1 / np.array(self.parent.peak_damping())
        ylabel = r&#39;Inverse Damping $1/\zeta$&#39;

    peak_freqs = self.parent.fft_frequencies()[self.parent.peaks()]

    # If a polynomial order is supplied assign it, if not default is 5
    if &#39;n&#39; in kwargs.keys():
        n = kwargs[&#39;n&#39;]
    else:
        n = 5

    # If labels are supplied the default color are used
    if &#39;label&#39; in plot_kwargs:
        plot_kwargs[&#39;color&#39;] = None
        plot2_kwargs = plot_kwargs.copy()
        plot2_kwargs[&#39;label&#39;] = None

    # If not black and red are used
    else:
        plot_kwargs[&#39;color&#39;] = &#39;r&#39;
        plot2_kwargs = plot_kwargs.copy()
        plot2_kwargs[&#39;color&#39;] = &#39;k&#39;

    if &#39;normalize&#39; in kwargs.keys() and kwargs[&#39;normalize&#39;]:
        zetas = np.array(zetas) / np.array(zetas).max()

    plt.scatter(peak_freqs, zetas, **plot_kwargs)
    fun = utils.nth_order_polynomial_fit(n, peak_freqs, zetas)
    freq = np.linspace(peak_freqs[0], peak_freqs[-1], 100)
    plt.plot(freq, fun(freq), **plot2_kwargs)
    plt.grid(&#39;on&#39;)
    plt.title(&#39;Frequency vs Damping Factor with Order &#39; + str(n))
    plt.xlabel(&#39;Frequency (Hz)&#39;)
    plt.ylabel(ylabel)

    if &#39;ticks&#39; in kwargs and kwargs[&#39;ticks&#39;] == &#39;bins&#39;:
        self.set_bin_ticks()</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.peaks"><code class="name flex">
<span>def <span class="ident">peaks</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the Fourier Transform of the Signal, with the peaks detected with the <code><a title="guitarsounds.analysis.Signal.peaks" href="#guitarsounds.analysis.Signal.peaks">Signal.peaks()</a></code> method.</p>
<p>If <code>peak_height = True</code> is supplied in the keyword arguments the computed height threshold is
shown on the plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peaks(self, **kwargs):
    &#34;&#34;&#34;
        Plots the Fourier Transform of the Signal, with the peaks detected with the `Signal.peaks()` method.

        If `peak_height = True` is supplied in the keyword arguments the computed height threshold is
        shown on the plot.
        &#34;&#34;&#34;

    plot_kwargs = self.sanitize_kwargs(kwargs)

    fft_freqs = self.parent.fft_frequencies()
    fft = self.parent.fft()
    max_index = np.where(fft_freqs &gt;= self.parent.SP.general.fft_range.value)[0][0]
    peak_indexes, height = self.parent.peaks(height=True)
    plt.xlabel(&#39;Fréquence (Hz)&#39;)
    plt.ylabel(&#39;Amplitude&#39;)
    plt.yscale(&#39;log&#39;)
    plt.grid(&#39;on&#39;)

    if &#39;color&#39; not in plot_kwargs.keys():
        plot_kwargs[&#39;color&#39;] = &#39;k&#39;
    plt.plot(fft_freqs[:max_index], fft[:max_index], **plot_kwargs)
    plt.scatter(fft_freqs[peak_indexes], fft[peak_indexes], color=&#39;r&#39;)
    if (&#39;peak_height&#39; in kwargs.keys()) and (kwargs[&#39;peak_height&#39;]):
        plt.plot(fft_freqs[:max_index], height, color=&#39;r&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.sanitize_kwargs"><code class="name flex">
<span>def <span class="ident">sanitize_kwargs</span></span>(<span>self, kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove illegal key words to supply the key word arguments to matplotlib
:param kwargs:
:return: sanitized kwargs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sanitize_kwargs(self, kwargs):
    &#34;&#34;&#34;
    Remove illegal key words to supply the key word arguments to matplotlib
    :param kwargs:
    :return: sanitized kwargs
    &#34;&#34;&#34;
    return {i: kwargs[i] for i in kwargs if i not in self.illegal_kwargs}</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.set_bin_ticks"><code class="name flex">
<span>def <span class="ident">set_bin_ticks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the frequency bin ticks to the current plot
:param kwargs:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_bin_ticks(self):
    &#34;&#34;&#34;
    Applies the frequency bin ticks to the current plot
    :param kwargs:
    :return:
    &#34;&#34;&#34;
    labels = [label for label in self.parent.SP.bins.__dict__ if label != &#39;name&#39;]
    labels.append(&#39;brillance&#39;)
    x = [param.value for param in self.parent.SP.bins.__dict__.values() if param != &#39;bins&#39;]
    x.append(11250)
    x_formatter = ticker.FixedFormatter(labels)
    x_locator = ticker.FixedLocator(x)
    ax = plt.gca()
    ax.xaxis.set_major_locator(x_locator)
    ax.xaxis.set_major_formatter(x_formatter)
    ax.tick_params(axis=&#34;x&#34;, labelrotation=90)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.signal"><code class="name flex">
<span>def <span class="ident">signal</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the time varying real signal as amplitude vs time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal(self, **kwargs):
    &#34;&#34;&#34;
        Plots the time varying real signal as amplitude vs time.
        &#34;&#34;&#34;
    plot_kwargs = self.sanitize_kwargs(kwargs)
    plt.plot(self.parent.time(), self.parent.signal, alpha=0.6, **plot_kwargs)
    plt.xlabel(&#39;time (s)&#39;)
    plt.ylabel(&#39;amplitude&#39;)
    plt.grid(&#39;on&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.timbre"><code class="name flex">
<span>def <span class="ident">timbre</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A polar plot of the timbral attributes of the signal</p>
<p>See help(guitarsounds.analysis.Signal.timbre) for more info about the timbral attributes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timbre(self, **kwargs):
    &#34;&#34;&#34;
        A polar plot of the timbral attributes of the signal

        See help(guitarsounds.analysis.Signal.timbre) for more info about the timbral attributes
        &#34;&#34;&#34;

    plot_kwargs = self.sanitize_kwargs(kwargs)

    fig = plt.gcf()
    if not fig.axes:  # case when the figure is empty
        ax = fig.add_subplot(projection=&#39;polar&#39;)

    elif plt.gca().name == &#39;polar&#39;:  # if the current ax is polar
        ax = plt.gca()

    timbre = self.parent.timbre()  # compute timbral attributes
    categories = list(timbre.keys())  # get the timbral categories
    values = list(timbre.values())  # get the timbral values
    N = len(values)  # Number of values
    values += values[:1]  # append the first value to the end to close the loop
    angles = [n / float(N) * 2 * np.pi for n in range(N)]  # N equidistant angles
    angles += angles[:1]  # append the first value at the end
    ax.plot(angles, values, lw=2, **plot_kwargs)
    if &#39;fill&#39; in kwargs and kwargs[&#39;fill&#39;]:
        ax.fill(angles, values)

    ax.set_yticks([])
    ax.set_yticklabels([])
    ax.set_xticks(angles[:-1])
    ax.set_xticklabels(categories)
    ax.xaxis.set_tick_params(pad=18)
    ax.set_theta_zero_location(&#39;S&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Plot.time_damping"><code class="name flex">
<span>def <span class="ident">time_damping</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the signal envelop with the fitted negative exponential curve used to determine the
time damping ratio of the signal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_damping(self, **kwargs):
    &#34;&#34;&#34;
        Shows the signal envelop with the fitted negative exponential curve used to determine the
        time damping ratio of the signal.
        &#34;&#34;&#34;
    plot_kwargs = self.sanitize_kwargs(kwargs)
    # Get the envelop data
    envelop_time = self.parent.normalize().envelop_time()
    envelop = self.parent.normalize().envelop()

    # First point is the maximum because e^-kt is stricly decreasing
    first_index = np.argmax(envelop)

    # The second point is the first point where the signal crosses the lower_threshold line
    second_point_thresh = self.parent.SP.damping.lower_threshold.value

    try:
        second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh)[0]
    except IndexError:
        second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh * 2)[0]

    # Function to compute the residual for the exponential curve fit
    def residual_function(zeta_w, t, s):
        return np.exp(zeta_w[0] * t) - s

    zeta_guess = [-0.5]

    result = scipy.optimize.least_squares(residual_function, zeta_guess,
                                          args=(envelop_time[first_index:second_index],
                                                envelop[first_index:second_index]))
    # Get the zeta*omega constant
    zeta_omega = result.x[0]

    # Compute the fundamental frequency in radiants of the signal
    wd = 2 * np.pi * self.parent.fundamental()

    # Plot the two points used for the regression
    plt.scatter(envelop_time[[first_index, second_index]], envelop[[first_index, second_index]], color=&#39;r&#39;)

    # get the current ax
    ax = plt.gca()

    # Plot the damping curve
    ax.plot(envelop_time[first_index:second_index],
            np.exp(zeta_omega * envelop_time[first_index:second_index]), c=&#39;k&#39;)

    plt.sca(ax)
    self.parent.normalize().plot.envelop(**plot_kwargs)

    if &#39;label&#39; not in plot_kwargs.keys():
        ax.legend([&#39;damping curve&#39;, &#39;signal envelop&#39;])

    title = &#39;Zeta : &#39; + str(np.around(-zeta_omega / wd, 5)) + &#39; Fundamental &#39; + \
            str(np.around(self.parent.fundamental(), 0)) + &#39;Hz&#39;
    plt.title(title)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="guitarsounds.analysis.Signal"><code class="flex name class">
<span>class <span class="ident">Signal</span></span>
<span>(</span><span>signal, sr, SoundParam, freq_range=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Class to do computations on an audio signal.</p>
<p>The signal is never changed in the class, when transformations are made, a new instance is returned.</p>
<p>Create a Signal class from a vector of samples and a sample rate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Signal(object):
    &#34;&#34;&#34;
    A Class to do computations on an audio signal.

    The signal is never changed in the class, when transformations are made, a new instance is returned.
    &#34;&#34;&#34;

    def __init__(self, signal, sr, SoundParam, freq_range=None):
        &#34;&#34;&#34; Create a Signal class from a vector of samples and a sample rate&#34;&#34;&#34;
        self.SP = SoundParam
        self.onset = None
        self.signal = signal
        self.sr = sr
        self.range = freq_range
        self.trimmed = None
        self.noise = None
        self.plot = Plot()
        self.plot.parent = self

    def time(self):
        &#34;&#34;&#34;
        Returns the time vector associated to the signal
        :return: numpy array corresponding to the time values of the signal samples in seconds
        &#34;&#34;&#34;
        return np.linspace(0, len(self.signal) * (1 / self.sr), len(self.signal))

    def listen(self):
        &#34;&#34;&#34;
        Method to listen the sound signal in a Jupyter Notebook

        Listening to the sounds imported in the analysis tool allows the
        user to validate if the sound was well trimmed and filtered

        A temporary file is created, the IPython display Audio function is
        called on it and then the file is removed
        &#34;&#34;&#34;
        file = &#39;temp.wav&#39;
        write(file, self.signal, self.sr)
        ipd.display(ipd.Audio(file))
        os.remove(file)

    def old_plot(self, kind, **kwargs):
        &#34;&#34;&#34;
        Convenience function for the different signal plots

        Calls the function corresponding to Plot.kind()
        See help(guitarsounds.analysis.Plot) for info on the different plots
        &#34;&#34;&#34;

        self.plot.method_dict[kind](**kwargs)

    def fft(self):
        &#34;&#34;&#34;
        Computes the Fast Fourier Transform of the signal and returns the vector.
        :return: Fast Fourier Transform amplitude values in a numpy array
        &#34;&#34;&#34;
        fft = np.fft.fft(self.signal)
        fft = np.abs(fft[:int(len(fft) // 2)])  # Only the symmetric of the absolute value
        return fft / np.max(fft)

    def peaks(self, max_freq=None, height=False, result=False):
        &#34;&#34;&#34;
        Computes the harmonic peaks indexes from the FFT of the signal
        :param max_freq: Supply a max frequency value overiding the one in guitarsounds_parameters
        :param height: if True the height threshold is returned to be used in the &#39;peaks&#39; plot
        :param result: if True the Scipy peak finding results dictionary is returned
        :return: peak indexes
        &#34;&#34;&#34;
        # Replace None by the default value
        if max_freq is None:
            max_freq = self.SP.general.fft_range.value

        # Get the fft and fft frequencies from the signal
        fft, fft_freq = self.fft(), self.fft_frequencies()

        # Find the max index
        max_index = np.where(fft_freq &gt;= max_freq)[0][0]

        # Find an approximation of the distance between peaks, this only works for harmonic signals
        peak_distance = np.argmax(fft) // 2

        # Maximum of the signal in a small region on both ends
        fft_max_start = np.max(fft[:peak_distance])
        fft_max_end = np.max(fft[max_index - peak_distance:max_index])

        # Build the curve below the peaks but above the noise
        exponents = np.linspace(np.log10(fft_max_start), np.log10(fft_max_end), max_index)
        intersect = 10 ** exponents[peak_distance]
        diff_start = fft_max_start - intersect  # offset by a small distance so that the first max is not a peak
        min_height = 10 ** np.linspace(np.log10(fft_max_start + diff_start), np.log10(fft_max_end), max_index)

        first_peak_indexes, _ = sig.find_peaks(fft[:max_index], height=min_height, distance=peak_distance)

        number_of_peaks = len(first_peak_indexes)
        if number_of_peaks &gt; 0:
            average_len = int(max_index / number_of_peaks) * 3
        else:
            average_len = int(max_index / 3)

        if average_len % 2 == 0:
            average_len += 1

        average_fft = sig.savgol_filter(fft[:max_index], average_len, 1, mode=&#39;mirror&#39;) * 1.9
        min_freq_index = np.where(fft_freq &gt;= 70)[0][0]
        average_fft[:min_freq_index] = 1

        peak_indexes, res = sig.find_peaks(fft[:max_index], height=average_fft, distance=min_freq_index)

        # Remove noisy peaks at the low frequencies
        while fft[peak_indexes[0]] &lt; 5e-2:
            peak_indexes = np.delete(peak_indexes, 0)
        while fft[peak_indexes[-1]] &lt; 1e-4:
            peak_indexes = np.delete(peak_indexes, -1)

        if not height and not result:
            return peak_indexes
        elif height:
            return peak_indexes, average_fft
        elif result:
            return peak_indexes, res
        elif height and result:
            return peak_indexes, height, res

    def time_damping(self):
        &#34;&#34;&#34;
        Computes the time wise damping ratio of the signal by fitting a negative exponential curve
        to the Signal envelop and computing the ratio with the Signal fundamental frequency.
        :return: The damping ratio, a scalar.
        &#34;&#34;&#34;
        # Get the envelop data
        envelop_time = self.normalize().envelop_time()
        envelop = self.normalize().envelop()

        # First point is the maximum because e^-kt is stricly decreasing
        first_index = np.argmax(envelop)

        # The second point is the first point where the signal crosses the lower_threshold line
        second_point_thresh = self.SP.damping.lower_threshold.value
        try:
            second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh)[0]
        except IndexError:
            second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh * 2)[0]

        # Function to compute the residual for the exponential curve fit
        def residual_function(zeta_w, t, s):
            &#34;&#34;&#34;
            Function computing the residual to curve fit a negative exponential to the signal envelop
            :param zeta_w: zeta*omega constant
            :param t: time vector
            :param s: signal
            :return: residual
            &#34;&#34;&#34;
            return np.exp(zeta_w[0] * t) - s

        zeta_guess = [-0.5]

        result = scipy.optimize.least_squares(residual_function, zeta_guess,
                                              args=(envelop_time[first_index:second_index],
                                                    envelop[first_index:second_index]))
        # Get the zeta*omega constant
        zeta_omega = result.x[0]

        # Compute the fundamental frequency in radiants of the signal
        wd = 2 * np.pi * self.fundamental()
        return -zeta_omega / wd

    def peak_damping(self):
        &#34;&#34;&#34;
        Computes the frequency wise damping with the half bandwidth method on the Fourier Transform peaks
        :return: an array containing the peak damping values
        &#34;&#34;&#34;
        zetas = []
        fft_freqs = self.fft_frequencies()
        fft = self.fft()[:len(fft_freqs)]
        for peak in self.peaks():
            peak_frequency = fft_freqs[peak]
            peak_height = fft[peak]
            root_height = peak_height / np.sqrt(2)
            frequency_roots = scipy.interpolate.InterpolatedUnivariateSpline(fft_freqs, fft - root_height).roots()
            sorted_roots_indexes = np.argsort(np.abs(frequency_roots - peak_frequency))
            w2, w1 = frequency_roots[sorted_roots_indexes[:2]]
            w1, w2 = np.sort([w1, w2])
            zeta = (w2 - w1) / (2 * peak_frequency)
            zetas.append(zeta)
        return np.array(zetas)

    def fundamental(self):
        &#34;&#34;&#34;
        Returns the fundamental approximated by the first peak of the fft
        :return: fundamental value (Hz)
        &#34;&#34;&#34;
        index = self.peaks()[0]
        fundamental = self.fft_frequencies()[index]
        return fundamental

    def cavity_peak(self):
        &#34;&#34;&#34;
        Finds the Hemlotz cavity frequency index from the Fourier Transform by searching for a peak in the expected
        range (80 - 100 Hz), if the fundamental is too close to the expected Hemlotz frequency a comment
        is printed and None is returned.
        :return: If successful the cavity peak index
        &#34;&#34;&#34;
        first_index = np.where(self.fft_frequencies() &gt;= 80)[0][0]
        second_index = np.where(self.fft_frequencies() &gt;= 110)[0][0]
        cavity_peak = np.argmax(self.fft()[first_index:second_index]) + first_index
        if self.fundamental() == self.fft_frequencies()[cavity_peak]:
            print(&#39;Cavity peak is obscured by the fundamental&#39;)
        else:
            return cavity_peak

    def cavity_frequency(self):
        &#34;&#34;&#34;
        Finds the hemlotz cavity frequency from the Fourier Transform by searching for a peak in the expected
        range (80 - 100 Hz), if the fundamental is too close to the expected hemlotz frequency a comment
        is printed and None is returned.
        :return: If successful, the cavity peak frequency
        &#34;&#34;&#34;
        first_index = np.where(self.fft_frequencies() &gt;= 80)[0][0]
        second_index = np.where(self.fft_frequencies() &gt;= 110)[0][0]
        cavity_peak = np.argmax(self.fft()[first_index:second_index]) + first_index
        if self.fundamental() == self.fft_frequencies()[cavity_peak]:
            print(&#39;Cavity peak is obscured by the fundamental&#39;)
            return 0
        else:
            return self.fft_frequencies()[cavity_peak]

    def fft_frequencies(self):
        &#34;&#34;&#34;
        Computes the frequency vector associated to the Signal Fourier Transform
        :return: an array containing the frequency values.
        &#34;&#34;&#34;
        fft = self.fft()
        fft_frequencies = np.fft.fftfreq(len(fft) * 2, 1 / self.sr)  # Frequencies corresponding to the bins
        return fft_frequencies[:len(fft)]

    def fft_bins(self):
        &#34;&#34;&#34;
        Transforms the Fourier Transform signal into a statistic distribution.
        Occurences of each frequency varies from 0 to 100 according to their
        amplitude.
        :return : a list containing the frequency occurences.
        &#34;&#34;&#34;

        # Make the FT values integers
        fft_integers = [int(np.around(sample * 100, 0)) for sample in self.fft()]

        # Create a list of the frequency occurrences in the signal
        occurrences = []
        for freq, count in zip(self.fft_frequencies(), fft_integers):
            occurrences.append([freq] * count)

        # flatten the list
        return [item for sublist in occurrences for item in sublist]

    def envelop(self):
        &#34;&#34;&#34;
        Method calculating the amplitude envelope of a signal as a
        maximum of the absolute value of the signal.
        :return: Amplitude envelop of the signal
        &#34;&#34;&#34;
        # Get the hop length
        hop_length = self.SP.envelop.hop_length.value

        # Compute the envelop
        envelop = np.array(
            [np.max(np.abs(self.signal[i:i + self.SP.envelop.frame_size.value])) for i in
             range(0, len(self.signal), hop_length)])

        envelop = np.insert(envelop, 0, 0)
        return envelop

    def envelop_time(self):
        &#34;&#34;&#34;
        Method calculating the time vector associated to a signal envelop
        :return: Time vector associated to the signal envelop
        &#34;&#34;&#34;
        # Get the number of frames from the signal envelop
        frames = range(len(self.envelop()))
        # Return the envelop frames computed with Librosa
        return librosa.frames_to_time(frames, hop_length=self.SP.envelop.hop_length.value)

    def log_envelop(self):
        &#34;&#34;&#34;
        Computes the logarithmic scale envelop of the signal.
        The width of the samples increases exponentially so that
        the envelop appears having a constant window width on
        an X axis logarithmic scale.
        :return: The log envelop and the time vector associated in a tuple
        &#34;&#34;&#34;
        if self.onset is None:
            onset = np.argmax(self.signal)
        else:
            onset = self.onset

        start_time = self.SP.log_envelop.start_time.value
        while start_time &gt; (onset / self.sr):
            start_time /= 10.

        start_exponent = int(np.log10(start_time))  # closest 10^x value for smooth graph

        if self.SP.log_envelop.min_window.value is None:
            min_window = 15 ** (start_exponent + 4)
            if min_window &lt; 15:  # Value should at least be 10
                min_window = 15
        else:
            min_window = self.SP.log_envelop.min_window.value

        # initial values
        current_exponent = start_exponent
        current_time = 10 ** current_exponent  # start time on log scale
        index = int(current_time * self.sr)  # Start at the specified time
        window = min_window  # number of samples per window
        overlap = window // 2
        log_envelop = []
        log_envelop_time = [0]  # First value for comparison

        while index + window &lt;= len(self.signal):

            while log_envelop_time[-1] &lt; 10 ** (current_exponent + 1):
                if (index + window) &lt; len(self.signal):
                    log_envelop.append(np.max(self.signal[index:index + window]))
                    log_envelop_time.append(self.time()[index])
                    index += overlap
                else:
                    break

            if window * 10 &lt; self.SP.log_envelop.max_window.value:
                window = window * 10
            else:
                window = self.SP.log_envelop.max_window.value

            overlap = window // 2
            current_exponent += 1

        # remove the value where t=0 so the log scale does not break
        log_envelop_time.remove(0)

        return np.array(log_envelop), np.array(log_envelop_time)

    def find_onset(self, verbose=True):
        &#34;&#34;&#34;
        Finds the onset as an increase in more of 50% with the maximum normalized value above 0.5
        :param verbose: Prints a warning if the algorithm does not converge
        :return: the index of the onset in the signal
        &#34;&#34;&#34;
        # Index corresponding to the onset time interval
        window_index = np.ceil(self.SP.onset.onset_time.value * self.sr).astype(int)
        # Use the normalized signal to compare against a fixed value
        onset_signal = self.normalize()
        overlap = window_index // 2  # overlap for algorithm progression
        # Initial values
        increase = 0
        i = 0
        broke = False
        while increase &lt;= 0.5:
            signal_min = np.min(np.abs(onset_signal.signal[i:i + window_index]))
            signal_max = np.max(np.abs(onset_signal.signal[i:i + window_index]))
            if (signal_max &gt; 0.5) and (signal_min != 0):
                increase = signal_max / signal_min
            else:
                increase = 0
            i += overlap
            if i + window_index &gt; len(self.signal):
                if verbose:
                    print(&#39;Onset detection did not converge \n&#39;)
                    print(&#39;Approximating onset with signal max value \n&#39;)
                    broke = True
                    break
        if broke:
            return np.argmax(self.signal)
        else:
            return np.argmax(np.abs(self.signal[i:i + window_index])) + i

    def trim_onset(self, verbose=True):
        &#34;&#34;&#34;
        Trim the signal at the onset (max) minus the delay in milliseconds as
        Specified in the SoundParameters
        :param : verbose if False the warning comments are not displayed
        :return : a trimmed signal with a noise attribute
        &#34;&#34;&#34;
        # nb of samples to keep before the onset
        delay_samples = int((self.SP.onset.onset_delay.value / 1000) * self.sr)
        onset = self.find_onset(verbose=verbose)  # find the onset

        if onset &gt; delay_samples:  # To make sure the index is positive
            trimmed_signal = Signal(self.signal[onset - delay_samples:], self.sr, self.SP)
            trimmed_signal.noise = self.signal[:onset - delay_samples]
            trimmed_signal.trimmed = True
            trimmed_signal.onset = np.argmax(trimmed_signal.signal)
            return trimmed_signal

        else:
            if verbose:
                print(&#39;Signal is too short to be trimmed before onset.&#39;)
                print(&#39;&#39;)
            self.trimmed = False
            return self

    def trim_time(self, time_length):
        &#34;&#34;&#34;
        Trims the signal to the specified length and returns a new Signal instance.
        :param time_length: desired length of the new signal in seconds.
        :return: A trimmed Signal
        &#34;&#34;&#34;
        max_index = int(time_length * self.sr)
        time_trimmed_signal = Signal(self.signal[:max_index], self.sr, self.SP)
        time_trimmed_signal.time_length = time_length
        return time_trimmed_signal

    def filter_noise(self, verbose=True):
        &#34;&#34;&#34;
        Method filtering the noise from the recorded signal and returning a filtered signal.
        If the signal was not trimmed it is trimmed in place then filtered.
        If the signal can not be trimmed it can&#39;t be filtered and the original signal is returned
        :return : A Signal instance, filtered if possible.
        &#34;&#34;&#34;
        try:
            return Signal(reduce_noise(audio_clip=self.signal, noise_clip=self.noise), self.sr, self.SP)
        except AttributeError:
            if self.trimmed is False:
                if verbose:
                    print(&#39;Not sufficient noise in the raw signal, unable to filter.&#39;)
                    print(&#39;&#39;)
                return self

    def normalize(self):
        &#34;&#34;&#34;
        Normalizes the signal to [-1, 1] and returns the normalised instance.
        :return : A normalized signal
        &#34;&#34;&#34;
        factor = np.max(np.abs(self.signal))
        normalised_signal = Signal((self.signal / factor), self.sr, self.SP)
        normalised_signal.norm_factor = (1 / factor)
        return normalised_signal

    def make_freq_bins(self):
        &#34;&#34;&#34;
        Method to divide a signal in frequency bins using butterworth filters
        bins are passed as a dict, default values are :
        - bass &lt; 100 Hz
        - mid = 100 - 700 Hz
        - highmid = 700 - 2000 Hz
        - uppermid = 2000 - 4000 Hz
        - presence = 4000 - 6000 Hz
        - brillance &gt; 6000 Hz
        :return : A dictionary with the divided signal as values and bin names as keys
        &#34;&#34;&#34;

        bins = self.SP.bins.__dict__

        bass_filter = sig.butter(12, bins[&#34;bass&#34;].value, &#39;lp&#39;, fs=self.sr, output=&#39;sos&#39;)
        mid_filter = sig.butter(12, [bins[&#34;bass&#34;].value, bins[&#39;mid&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
        himid_filter = sig.butter(12, [bins[&#34;mid&#34;].value, bins[&#39;highmid&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
        upmid_filter = sig.butter(12, [bins[&#34;highmid&#34;].value, bins[&#39;uppermid&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
        pres_filter = sig.butter(12, [bins[&#34;uppermid&#34;].value, bins[&#39;presence&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
        bril_filter = sig.butter(12, bins[&#39;presence&#39;].value, &#39;hp&#39;, fs=self.sr, output=&#39;sos&#39;)

        return {
            &#34;bass&#34;: Signal(sig.sosfilt(bass_filter, self.signal), self.sr, self.SP,
                           freq_range=[0, bins[&#34;bass&#34;].value]),
            &#34;mid&#34;: Signal(sig.sosfilt(mid_filter, self.signal), self.sr, self.SP,
                          freq_range=[bins[&#34;bass&#34;].value, bins[&#34;mid&#34;].value]),
            &#34;highmid&#34;: Signal(sig.sosfilt(himid_filter, self.signal), self.sr, self.SP,
                              freq_range=[bins[&#34;mid&#34;].value, bins[&#34;highmid&#34;].value]),
            &#34;uppermid&#34;: Signal(sig.sosfilt(upmid_filter, self.signal), self.sr, self.SP,
                               freq_range=[bins[&#34;highmid&#34;].value, bins[&#34;uppermid&#34;].value]),
            &#34;presence&#34;: Signal(sig.sosfilt(pres_filter, self.signal), self.sr, self.SP,
                               freq_range=[bins[&#39;uppermid&#39;].value, bins[&#34;presence&#34;].value]),
            &#34;brillance&#34;: Signal(sig.sosfilt(bril_filter, self.signal), self.sr, self.SP,
                                freq_range=[bins[&#34;presence&#34;].value, max(self.fft_frequencies())])}

    def timbre(self):
        &#34;&#34;&#34;
        A method computing the timbral attributes of the signal

        This method returns timbral attributes &#34;Brightness&#34;, &#34;Depth&#34;, &#34;Boominess&#34;, &#34;Sharpness&#34; and &#34;Warmth&#34;.
        They are obtained trough linear regression with a model trained with regular sounds.
        More information :
        Andy Pearce, Mark Plumbley, Saeid, S., Brookes, T., Mason, R., &amp; Wang, W. (2019).
        Release of timbral characterisation tools for semantically annotating non-musical content.pdf
        (Rapport No. AC-WP5-SURREY-D5.8). AudioCommons. Repéré à :
        https://www.audiocommons.org/assets/files/AC-WP5-SURREY-D5.8%20Release%20of%20timbral
        %20characterisation%20tools%20for%20semantically%20annotating%20non-musical%20content.pdf
        :return: A dictionary with timbral attributes and their values
        &#34;&#34;&#34;
        # Save the signal in a temporary file
        self.save_wav(&#39;temp&#39;)
        # Compute the timbre dict from the temp file
        timbre = timbral_extractor(&#39;temp.wav&#39;, verbose=False)
        # remove reverb and roughness and hardness attributes
        timbre = {key: timbre[key] for key in timbre if key not in [&#39;reverb&#39;, &#39;roughness&#39;, &#39;hardness&#39;]}
        # Remove the temp file
        os.remove(&#39;temp.wav&#39;)
        return timbre

    def save_wav(self, name, path=&#39;&#39;):
        &#34;&#34;&#34;
        Create a soundfile from a signal
        :param name: the name of the saved file
        :param path: the path were the &#39;.wav&#39; file is saved
        &#34;&#34;&#34;
        write(path + name + &#34;.wav&#34;, self.signal, self.sr)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="guitarsounds.analysis.Signal.cavity_frequency"><code class="name flex">
<span>def <span class="ident">cavity_frequency</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the hemlotz cavity frequency from the Fourier Transform by searching for a peak in the expected
range (80 - 100 Hz), if the fundamental is too close to the expected hemlotz frequency a comment
is printed and None is returned.
:return: If successful, the cavity peak frequency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cavity_frequency(self):
    &#34;&#34;&#34;
    Finds the hemlotz cavity frequency from the Fourier Transform by searching for a peak in the expected
    range (80 - 100 Hz), if the fundamental is too close to the expected hemlotz frequency a comment
    is printed and None is returned.
    :return: If successful, the cavity peak frequency
    &#34;&#34;&#34;
    first_index = np.where(self.fft_frequencies() &gt;= 80)[0][0]
    second_index = np.where(self.fft_frequencies() &gt;= 110)[0][0]
    cavity_peak = np.argmax(self.fft()[first_index:second_index]) + first_index
    if self.fundamental() == self.fft_frequencies()[cavity_peak]:
        print(&#39;Cavity peak is obscured by the fundamental&#39;)
        return 0
    else:
        return self.fft_frequencies()[cavity_peak]</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.cavity_peak"><code class="name flex">
<span>def <span class="ident">cavity_peak</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the Hemlotz cavity frequency index from the Fourier Transform by searching for a peak in the expected
range (80 - 100 Hz), if the fundamental is too close to the expected Hemlotz frequency a comment
is printed and None is returned.
:return: If successful the cavity peak index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cavity_peak(self):
    &#34;&#34;&#34;
    Finds the Hemlotz cavity frequency index from the Fourier Transform by searching for a peak in the expected
    range (80 - 100 Hz), if the fundamental is too close to the expected Hemlotz frequency a comment
    is printed and None is returned.
    :return: If successful the cavity peak index
    &#34;&#34;&#34;
    first_index = np.where(self.fft_frequencies() &gt;= 80)[0][0]
    second_index = np.where(self.fft_frequencies() &gt;= 110)[0][0]
    cavity_peak = np.argmax(self.fft()[first_index:second_index]) + first_index
    if self.fundamental() == self.fft_frequencies()[cavity_peak]:
        print(&#39;Cavity peak is obscured by the fundamental&#39;)
    else:
        return cavity_peak</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.envelop"><code class="name flex">
<span>def <span class="ident">envelop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method calculating the amplitude envelope of a signal as a
maximum of the absolute value of the signal.
:return: Amplitude envelop of the signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def envelop(self):
    &#34;&#34;&#34;
    Method calculating the amplitude envelope of a signal as a
    maximum of the absolute value of the signal.
    :return: Amplitude envelop of the signal
    &#34;&#34;&#34;
    # Get the hop length
    hop_length = self.SP.envelop.hop_length.value

    # Compute the envelop
    envelop = np.array(
        [np.max(np.abs(self.signal[i:i + self.SP.envelop.frame_size.value])) for i in
         range(0, len(self.signal), hop_length)])

    envelop = np.insert(envelop, 0, 0)
    return envelop</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.envelop_time"><code class="name flex">
<span>def <span class="ident">envelop_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method calculating the time vector associated to a signal envelop
:return: Time vector associated to the signal envelop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def envelop_time(self):
    &#34;&#34;&#34;
    Method calculating the time vector associated to a signal envelop
    :return: Time vector associated to the signal envelop
    &#34;&#34;&#34;
    # Get the number of frames from the signal envelop
    frames = range(len(self.envelop()))
    # Return the envelop frames computed with Librosa
    return librosa.frames_to_time(frames, hop_length=self.SP.envelop.hop_length.value)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.fft"><code class="name flex">
<span>def <span class="ident">fft</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the Fast Fourier Transform of the signal and returns the vector.
:return: Fast Fourier Transform amplitude values in a numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fft(self):
    &#34;&#34;&#34;
    Computes the Fast Fourier Transform of the signal and returns the vector.
    :return: Fast Fourier Transform amplitude values in a numpy array
    &#34;&#34;&#34;
    fft = np.fft.fft(self.signal)
    fft = np.abs(fft[:int(len(fft) // 2)])  # Only the symmetric of the absolute value
    return fft / np.max(fft)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.fft_bins"><code class="name flex">
<span>def <span class="ident">fft_bins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the Fourier Transform signal into a statistic distribution.
Occurences of each frequency varies from 0 to 100 according to their
amplitude.
:return : a list containing the frequency occurences.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fft_bins(self):
    &#34;&#34;&#34;
    Transforms the Fourier Transform signal into a statistic distribution.
    Occurences of each frequency varies from 0 to 100 according to their
    amplitude.
    :return : a list containing the frequency occurences.
    &#34;&#34;&#34;

    # Make the FT values integers
    fft_integers = [int(np.around(sample * 100, 0)) for sample in self.fft()]

    # Create a list of the frequency occurrences in the signal
    occurrences = []
    for freq, count in zip(self.fft_frequencies(), fft_integers):
        occurrences.append([freq] * count)

    # flatten the list
    return [item for sublist in occurrences for item in sublist]</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.fft_frequencies"><code class="name flex">
<span>def <span class="ident">fft_frequencies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the frequency vector associated to the Signal Fourier Transform
:return: an array containing the frequency values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fft_frequencies(self):
    &#34;&#34;&#34;
    Computes the frequency vector associated to the Signal Fourier Transform
    :return: an array containing the frequency values.
    &#34;&#34;&#34;
    fft = self.fft()
    fft_frequencies = np.fft.fftfreq(len(fft) * 2, 1 / self.sr)  # Frequencies corresponding to the bins
    return fft_frequencies[:len(fft)]</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.filter_noise"><code class="name flex">
<span>def <span class="ident">filter_noise</span></span>(<span>self, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Method filtering the noise from the recorded signal and returning a filtered signal.
If the signal was not trimmed it is trimmed in place then filtered.
If the signal can not be trimmed it can't be filtered and the original signal is returned
:return : A Signal instance, filtered if possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_noise(self, verbose=True):
    &#34;&#34;&#34;
    Method filtering the noise from the recorded signal and returning a filtered signal.
    If the signal was not trimmed it is trimmed in place then filtered.
    If the signal can not be trimmed it can&#39;t be filtered and the original signal is returned
    :return : A Signal instance, filtered if possible.
    &#34;&#34;&#34;
    try:
        return Signal(reduce_noise(audio_clip=self.signal, noise_clip=self.noise), self.sr, self.SP)
    except AttributeError:
        if self.trimmed is False:
            if verbose:
                print(&#39;Not sufficient noise in the raw signal, unable to filter.&#39;)
                print(&#39;&#39;)
            return self</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.find_onset"><code class="name flex">
<span>def <span class="ident">find_onset</span></span>(<span>self, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the onset as an increase in more of 50% with the maximum normalized value above 0.5
:param verbose: Prints a warning if the algorithm does not converge
:return: the index of the onset in the signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_onset(self, verbose=True):
    &#34;&#34;&#34;
    Finds the onset as an increase in more of 50% with the maximum normalized value above 0.5
    :param verbose: Prints a warning if the algorithm does not converge
    :return: the index of the onset in the signal
    &#34;&#34;&#34;
    # Index corresponding to the onset time interval
    window_index = np.ceil(self.SP.onset.onset_time.value * self.sr).astype(int)
    # Use the normalized signal to compare against a fixed value
    onset_signal = self.normalize()
    overlap = window_index // 2  # overlap for algorithm progression
    # Initial values
    increase = 0
    i = 0
    broke = False
    while increase &lt;= 0.5:
        signal_min = np.min(np.abs(onset_signal.signal[i:i + window_index]))
        signal_max = np.max(np.abs(onset_signal.signal[i:i + window_index]))
        if (signal_max &gt; 0.5) and (signal_min != 0):
            increase = signal_max / signal_min
        else:
            increase = 0
        i += overlap
        if i + window_index &gt; len(self.signal):
            if verbose:
                print(&#39;Onset detection did not converge \n&#39;)
                print(&#39;Approximating onset with signal max value \n&#39;)
                broke = True
                break
    if broke:
        return np.argmax(self.signal)
    else:
        return np.argmax(np.abs(self.signal[i:i + window_index])) + i</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.fundamental"><code class="name flex">
<span>def <span class="ident">fundamental</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the fundamental approximated by the first peak of the fft
:return: fundamental value (Hz)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fundamental(self):
    &#34;&#34;&#34;
    Returns the fundamental approximated by the first peak of the fft
    :return: fundamental value (Hz)
    &#34;&#34;&#34;
    index = self.peaks()[0]
    fundamental = self.fft_frequencies()[index]
    return fundamental</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.listen"><code class="name flex">
<span>def <span class="ident">listen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to listen the sound signal in a Jupyter Notebook</p>
<p>Listening to the sounds imported in the analysis tool allows the
user to validate if the sound was well trimmed and filtered</p>
<p>A temporary file is created, the IPython display Audio function is
called on it and then the file is removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listen(self):
    &#34;&#34;&#34;
    Method to listen the sound signal in a Jupyter Notebook

    Listening to the sounds imported in the analysis tool allows the
    user to validate if the sound was well trimmed and filtered

    A temporary file is created, the IPython display Audio function is
    called on it and then the file is removed
    &#34;&#34;&#34;
    file = &#39;temp.wav&#39;
    write(file, self.signal, self.sr)
    ipd.display(ipd.Audio(file))
    os.remove(file)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.log_envelop"><code class="name flex">
<span>def <span class="ident">log_envelop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the logarithmic scale envelop of the signal.
The width of the samples increases exponentially so that
the envelop appears having a constant window width on
an X axis logarithmic scale.
:return: The log envelop and the time vector associated in a tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_envelop(self):
    &#34;&#34;&#34;
    Computes the logarithmic scale envelop of the signal.
    The width of the samples increases exponentially so that
    the envelop appears having a constant window width on
    an X axis logarithmic scale.
    :return: The log envelop and the time vector associated in a tuple
    &#34;&#34;&#34;
    if self.onset is None:
        onset = np.argmax(self.signal)
    else:
        onset = self.onset

    start_time = self.SP.log_envelop.start_time.value
    while start_time &gt; (onset / self.sr):
        start_time /= 10.

    start_exponent = int(np.log10(start_time))  # closest 10^x value for smooth graph

    if self.SP.log_envelop.min_window.value is None:
        min_window = 15 ** (start_exponent + 4)
        if min_window &lt; 15:  # Value should at least be 10
            min_window = 15
    else:
        min_window = self.SP.log_envelop.min_window.value

    # initial values
    current_exponent = start_exponent
    current_time = 10 ** current_exponent  # start time on log scale
    index = int(current_time * self.sr)  # Start at the specified time
    window = min_window  # number of samples per window
    overlap = window // 2
    log_envelop = []
    log_envelop_time = [0]  # First value for comparison

    while index + window &lt;= len(self.signal):

        while log_envelop_time[-1] &lt; 10 ** (current_exponent + 1):
            if (index + window) &lt; len(self.signal):
                log_envelop.append(np.max(self.signal[index:index + window]))
                log_envelop_time.append(self.time()[index])
                index += overlap
            else:
                break

        if window * 10 &lt; self.SP.log_envelop.max_window.value:
            window = window * 10
        else:
            window = self.SP.log_envelop.max_window.value

        overlap = window // 2
        current_exponent += 1

    # remove the value where t=0 so the log scale does not break
    log_envelop_time.remove(0)

    return np.array(log_envelop), np.array(log_envelop_time)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.make_freq_bins"><code class="name flex">
<span>def <span class="ident">make_freq_bins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to divide a signal in frequency bins using butterworth filters
bins are passed as a dict, default values are :
- bass &lt; 100 Hz
- mid = 100 - 700 Hz
- highmid = 700 - 2000 Hz
- uppermid = 2000 - 4000 Hz
- presence = 4000 - 6000 Hz
- brillance &gt; 6000 Hz
:return : A dictionary with the divided signal as values and bin names as keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_freq_bins(self):
    &#34;&#34;&#34;
    Method to divide a signal in frequency bins using butterworth filters
    bins are passed as a dict, default values are :
    - bass &lt; 100 Hz
    - mid = 100 - 700 Hz
    - highmid = 700 - 2000 Hz
    - uppermid = 2000 - 4000 Hz
    - presence = 4000 - 6000 Hz
    - brillance &gt; 6000 Hz
    :return : A dictionary with the divided signal as values and bin names as keys
    &#34;&#34;&#34;

    bins = self.SP.bins.__dict__

    bass_filter = sig.butter(12, bins[&#34;bass&#34;].value, &#39;lp&#39;, fs=self.sr, output=&#39;sos&#39;)
    mid_filter = sig.butter(12, [bins[&#34;bass&#34;].value, bins[&#39;mid&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
    himid_filter = sig.butter(12, [bins[&#34;mid&#34;].value, bins[&#39;highmid&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
    upmid_filter = sig.butter(12, [bins[&#34;highmid&#34;].value, bins[&#39;uppermid&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
    pres_filter = sig.butter(12, [bins[&#34;uppermid&#34;].value, bins[&#39;presence&#39;].value], &#39;bp&#39;, fs=self.sr, output=&#39;sos&#39;)
    bril_filter = sig.butter(12, bins[&#39;presence&#39;].value, &#39;hp&#39;, fs=self.sr, output=&#39;sos&#39;)

    return {
        &#34;bass&#34;: Signal(sig.sosfilt(bass_filter, self.signal), self.sr, self.SP,
                       freq_range=[0, bins[&#34;bass&#34;].value]),
        &#34;mid&#34;: Signal(sig.sosfilt(mid_filter, self.signal), self.sr, self.SP,
                      freq_range=[bins[&#34;bass&#34;].value, bins[&#34;mid&#34;].value]),
        &#34;highmid&#34;: Signal(sig.sosfilt(himid_filter, self.signal), self.sr, self.SP,
                          freq_range=[bins[&#34;mid&#34;].value, bins[&#34;highmid&#34;].value]),
        &#34;uppermid&#34;: Signal(sig.sosfilt(upmid_filter, self.signal), self.sr, self.SP,
                           freq_range=[bins[&#34;highmid&#34;].value, bins[&#34;uppermid&#34;].value]),
        &#34;presence&#34;: Signal(sig.sosfilt(pres_filter, self.signal), self.sr, self.SP,
                           freq_range=[bins[&#39;uppermid&#39;].value, bins[&#34;presence&#34;].value]),
        &#34;brillance&#34;: Signal(sig.sosfilt(bril_filter, self.signal), self.sr, self.SP,
                            freq_range=[bins[&#34;presence&#34;].value, max(self.fft_frequencies())])}</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalizes the signal to [-1, 1] and returns the normalised instance.
:return : A normalized signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(self):
    &#34;&#34;&#34;
    Normalizes the signal to [-1, 1] and returns the normalised instance.
    :return : A normalized signal
    &#34;&#34;&#34;
    factor = np.max(np.abs(self.signal))
    normalised_signal = Signal((self.signal / factor), self.sr, self.SP)
    normalised_signal.norm_factor = (1 / factor)
    return normalised_signal</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.old_plot"><code class="name flex">
<span>def <span class="ident">old_plot</span></span>(<span>self, kind, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function for the different signal plots</p>
<p>Calls the function corresponding to Plot.kind()
See help(guitarsounds.analysis.Plot) for info on the different plots</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def old_plot(self, kind, **kwargs):
    &#34;&#34;&#34;
    Convenience function for the different signal plots

    Calls the function corresponding to Plot.kind()
    See help(guitarsounds.analysis.Plot) for info on the different plots
    &#34;&#34;&#34;

    self.plot.method_dict[kind](**kwargs)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.peak_damping"><code class="name flex">
<span>def <span class="ident">peak_damping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the frequency wise damping with the half bandwidth method on the Fourier Transform peaks
:return: an array containing the peak damping values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_damping(self):
    &#34;&#34;&#34;
    Computes the frequency wise damping with the half bandwidth method on the Fourier Transform peaks
    :return: an array containing the peak damping values
    &#34;&#34;&#34;
    zetas = []
    fft_freqs = self.fft_frequencies()
    fft = self.fft()[:len(fft_freqs)]
    for peak in self.peaks():
        peak_frequency = fft_freqs[peak]
        peak_height = fft[peak]
        root_height = peak_height / np.sqrt(2)
        frequency_roots = scipy.interpolate.InterpolatedUnivariateSpline(fft_freqs, fft - root_height).roots()
        sorted_roots_indexes = np.argsort(np.abs(frequency_roots - peak_frequency))
        w2, w1 = frequency_roots[sorted_roots_indexes[:2]]
        w1, w2 = np.sort([w1, w2])
        zeta = (w2 - w1) / (2 * peak_frequency)
        zetas.append(zeta)
    return np.array(zetas)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.peaks"><code class="name flex">
<span>def <span class="ident">peaks</span></span>(<span>self, max_freq=None, height=False, result=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the harmonic peaks indexes from the FFT of the signal
:param max_freq: Supply a max frequency value overiding the one in guitarsounds_parameters
:param height: if True the height threshold is returned to be used in the 'peaks' plot
:param result: if True the Scipy peak finding results dictionary is returned
:return: peak indexes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peaks(self, max_freq=None, height=False, result=False):
    &#34;&#34;&#34;
    Computes the harmonic peaks indexes from the FFT of the signal
    :param max_freq: Supply a max frequency value overiding the one in guitarsounds_parameters
    :param height: if True the height threshold is returned to be used in the &#39;peaks&#39; plot
    :param result: if True the Scipy peak finding results dictionary is returned
    :return: peak indexes
    &#34;&#34;&#34;
    # Replace None by the default value
    if max_freq is None:
        max_freq = self.SP.general.fft_range.value

    # Get the fft and fft frequencies from the signal
    fft, fft_freq = self.fft(), self.fft_frequencies()

    # Find the max index
    max_index = np.where(fft_freq &gt;= max_freq)[0][0]

    # Find an approximation of the distance between peaks, this only works for harmonic signals
    peak_distance = np.argmax(fft) // 2

    # Maximum of the signal in a small region on both ends
    fft_max_start = np.max(fft[:peak_distance])
    fft_max_end = np.max(fft[max_index - peak_distance:max_index])

    # Build the curve below the peaks but above the noise
    exponents = np.linspace(np.log10(fft_max_start), np.log10(fft_max_end), max_index)
    intersect = 10 ** exponents[peak_distance]
    diff_start = fft_max_start - intersect  # offset by a small distance so that the first max is not a peak
    min_height = 10 ** np.linspace(np.log10(fft_max_start + diff_start), np.log10(fft_max_end), max_index)

    first_peak_indexes, _ = sig.find_peaks(fft[:max_index], height=min_height, distance=peak_distance)

    number_of_peaks = len(first_peak_indexes)
    if number_of_peaks &gt; 0:
        average_len = int(max_index / number_of_peaks) * 3
    else:
        average_len = int(max_index / 3)

    if average_len % 2 == 0:
        average_len += 1

    average_fft = sig.savgol_filter(fft[:max_index], average_len, 1, mode=&#39;mirror&#39;) * 1.9
    min_freq_index = np.where(fft_freq &gt;= 70)[0][0]
    average_fft[:min_freq_index] = 1

    peak_indexes, res = sig.find_peaks(fft[:max_index], height=average_fft, distance=min_freq_index)

    # Remove noisy peaks at the low frequencies
    while fft[peak_indexes[0]] &lt; 5e-2:
        peak_indexes = np.delete(peak_indexes, 0)
    while fft[peak_indexes[-1]] &lt; 1e-4:
        peak_indexes = np.delete(peak_indexes, -1)

    if not height and not result:
        return peak_indexes
    elif height:
        return peak_indexes, average_fft
    elif result:
        return peak_indexes, res
    elif height and result:
        return peak_indexes, height, res</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.save_wav"><code class="name flex">
<span>def <span class="ident">save_wav</span></span>(<span>self, name, path='')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a soundfile from a signal
:param name: the name of the saved file
:param path: the path were the '.wav' file is saved</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_wav(self, name, path=&#39;&#39;):
    &#34;&#34;&#34;
    Create a soundfile from a signal
    :param name: the name of the saved file
    :param path: the path were the &#39;.wav&#39; file is saved
    &#34;&#34;&#34;
    write(path + name + &#34;.wav&#34;, self.signal, self.sr)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.timbre"><code class="name flex">
<span>def <span class="ident">timbre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A method computing the timbral attributes of the signal</p>
<p>This method returns timbral attributes "Brightness", "Depth", "Boominess", "Sharpness" and "Warmth".
They are obtained trough linear regression with a model trained with regular sounds.
More information :
Andy Pearce, Mark Plumbley, Saeid, S., Brookes, T., Mason, R., &amp; Wang, W. (2019).
Release of timbral characterisation tools for semantically annotating non-musical content.pdf
(Rapport No. AC-WP5-SURREY-D5.8). AudioCommons. Repéré à :
<a href="https://www.audiocommons.org/assets/files/AC-WP5-SURREY-D5.8%20Release%20of%20timbral">https://www.audiocommons.org/assets/files/AC-WP5-SURREY-D5.8%20Release%20of%20timbral</a>
%20characterisation%20tools%20for%20semantically%20annotating%20non-musical%20content.pdf
:return: A dictionary with timbral attributes and their values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timbre(self):
    &#34;&#34;&#34;
    A method computing the timbral attributes of the signal

    This method returns timbral attributes &#34;Brightness&#34;, &#34;Depth&#34;, &#34;Boominess&#34;, &#34;Sharpness&#34; and &#34;Warmth&#34;.
    They are obtained trough linear regression with a model trained with regular sounds.
    More information :
    Andy Pearce, Mark Plumbley, Saeid, S., Brookes, T., Mason, R., &amp; Wang, W. (2019).
    Release of timbral characterisation tools for semantically annotating non-musical content.pdf
    (Rapport No. AC-WP5-SURREY-D5.8). AudioCommons. Repéré à :
    https://www.audiocommons.org/assets/files/AC-WP5-SURREY-D5.8%20Release%20of%20timbral
    %20characterisation%20tools%20for%20semantically%20annotating%20non-musical%20content.pdf
    :return: A dictionary with timbral attributes and their values
    &#34;&#34;&#34;
    # Save the signal in a temporary file
    self.save_wav(&#39;temp&#39;)
    # Compute the timbre dict from the temp file
    timbre = timbral_extractor(&#39;temp.wav&#39;, verbose=False)
    # remove reverb and roughness and hardness attributes
    timbre = {key: timbre[key] for key in timbre if key not in [&#39;reverb&#39;, &#39;roughness&#39;, &#39;hardness&#39;]}
    # Remove the temp file
    os.remove(&#39;temp.wav&#39;)
    return timbre</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.time"><code class="name flex">
<span>def <span class="ident">time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the time vector associated to the signal
:return: numpy array corresponding to the time values of the signal samples in seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time(self):
    &#34;&#34;&#34;
    Returns the time vector associated to the signal
    :return: numpy array corresponding to the time values of the signal samples in seconds
    &#34;&#34;&#34;
    return np.linspace(0, len(self.signal) * (1 / self.sr), len(self.signal))</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.time_damping"><code class="name flex">
<span>def <span class="ident">time_damping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the time wise damping ratio of the signal by fitting a negative exponential curve
to the Signal envelop and computing the ratio with the Signal fundamental frequency.
:return: The damping ratio, a scalar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_damping(self):
    &#34;&#34;&#34;
    Computes the time wise damping ratio of the signal by fitting a negative exponential curve
    to the Signal envelop and computing the ratio with the Signal fundamental frequency.
    :return: The damping ratio, a scalar.
    &#34;&#34;&#34;
    # Get the envelop data
    envelop_time = self.normalize().envelop_time()
    envelop = self.normalize().envelop()

    # First point is the maximum because e^-kt is stricly decreasing
    first_index = np.argmax(envelop)

    # The second point is the first point where the signal crosses the lower_threshold line
    second_point_thresh = self.SP.damping.lower_threshold.value
    try:
        second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh)[0]
    except IndexError:
        second_index = np.flatnonzero(envelop[first_index:] &lt;= second_point_thresh * 2)[0]

    # Function to compute the residual for the exponential curve fit
    def residual_function(zeta_w, t, s):
        &#34;&#34;&#34;
        Function computing the residual to curve fit a negative exponential to the signal envelop
        :param zeta_w: zeta*omega constant
        :param t: time vector
        :param s: signal
        :return: residual
        &#34;&#34;&#34;
        return np.exp(zeta_w[0] * t) - s

    zeta_guess = [-0.5]

    result = scipy.optimize.least_squares(residual_function, zeta_guess,
                                          args=(envelop_time[first_index:second_index],
                                                envelop[first_index:second_index]))
    # Get the zeta*omega constant
    zeta_omega = result.x[0]

    # Compute the fundamental frequency in radiants of the signal
    wd = 2 * np.pi * self.fundamental()
    return -zeta_omega / wd</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.trim_onset"><code class="name flex">
<span>def <span class="ident">trim_onset</span></span>(<span>self, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Trim the signal at the onset (max) minus the delay in milliseconds as
Specified in the SoundParameters
:param : verbose if False the warning comments are not displayed
:return : a trimmed signal with a noise attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trim_onset(self, verbose=True):
    &#34;&#34;&#34;
    Trim the signal at the onset (max) minus the delay in milliseconds as
    Specified in the SoundParameters
    :param : verbose if False the warning comments are not displayed
    :return : a trimmed signal with a noise attribute
    &#34;&#34;&#34;
    # nb of samples to keep before the onset
    delay_samples = int((self.SP.onset.onset_delay.value / 1000) * self.sr)
    onset = self.find_onset(verbose=verbose)  # find the onset

    if onset &gt; delay_samples:  # To make sure the index is positive
        trimmed_signal = Signal(self.signal[onset - delay_samples:], self.sr, self.SP)
        trimmed_signal.noise = self.signal[:onset - delay_samples]
        trimmed_signal.trimmed = True
        trimmed_signal.onset = np.argmax(trimmed_signal.signal)
        return trimmed_signal

    else:
        if verbose:
            print(&#39;Signal is too short to be trimmed before onset.&#39;)
            print(&#39;&#39;)
        self.trimmed = False
        return self</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Signal.trim_time"><code class="name flex">
<span>def <span class="ident">trim_time</span></span>(<span>self, time_length)</span>
</code></dt>
<dd>
<div class="desc"><p>Trims the signal to the specified length and returns a new Signal instance.
:param time_length: desired length of the new signal in seconds.
:return: A trimmed Signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trim_time(self, time_length):
    &#34;&#34;&#34;
    Trims the signal to the specified length and returns a new Signal instance.
    :param time_length: desired length of the new signal in seconds.
    :return: A trimmed Signal
    &#34;&#34;&#34;
    max_index = int(time_length * self.sr)
    time_trimmed_signal = Signal(self.signal[:max_index], self.sr, self.SP)
    time_trimmed_signal.time_length = time_length
    return time_trimmed_signal</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="guitarsounds.analysis.Sound"><code class="flex name class">
<span>class <span class="ident">Sound</span></span>
<span>(</span><span>file, name='', fundamental=None, SoundParams=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to store audio signals obtained from a sound and compare them</p>
<p>Creates a Sound instance from a .wav file, name as a string and fundamental frequency
value can be user specified.
:param file: file path to the .wav file
:param name: Sound instance name to use in plot legend and titles
:param fundamental: Fundamental frequency value if None the value is estimated
from the FFT (see <code><a title="guitarsounds.analysis.Signal.fundamental" href="#guitarsounds.analysis.Signal.fundamental">Signal.fundamental()</a></code>).
:param SoundParams: SoundParameters to use in the Sound instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sound(object):
    &#34;&#34;&#34;
    A class to store audio signals obtained from a sound and compare them
    &#34;&#34;&#34;

    def __init__(self, file, name=&#39;&#39;, fundamental=None, SoundParams=None):
        &#34;&#34;&#34;
        Creates a Sound instance from a .wav file, name as a string and fundamental frequency
        value can be user specified.
        :param file: file path to the .wav file
        :param name: Sound instance name to use in plot legend and titles
        :param fundamental: Fundamental frequency value if None the value is estimated
        from the FFT (see `Signal.fundamental`).
        :param SoundParams: SoundParameters to use in the Sound instance
        &#34;&#34;&#34;
        # create a reference of the parameters
        if SoundParams is None:
            self.SP = SP
        else:
            self.SP = SoundParams

        if type(file) == str:
            # Load the soundfile using librosa
            signal, sr = librosa.load(file)
            self.file = file

        elif type(file) == tuple:
            signal, sr = file

        # create a Signal class from the signal and sample rate
        self.raw_signal = Signal(signal, sr, self.SP)

        # Allow user specified fundamental
        self.fundamental = fundamental
        self.name = name

    def condition(self, verbose=True, return_self=False):
        &#34;&#34;&#34;
        A method conditioning the Sound instance.
        - Trimming to just before the onset
        - Filtering the noise
        :param verbose: if True problem with trimming and filtering are reported
        :param return_self: If True the method returns the conditioned Sound instance
        :return: a conditioned Sound instance if `return_self = True`
        &#34;&#34;&#34;
        self.trim_signal(verbose=verbose)
        self.filter_noise(verbose=verbose)
        self.bin_divide()
        if self.fundamental is None:
            self.fundamental = self.signal.fundamental()
        self.plot = self.signal.plot
        if return_self:
            return self

    def use_raw_signal(self, normalized=False):
        &#34;&#34;&#34;
        Assigns the raw signal to the `signal` attribute of the Sound instance to
        analyze it
        :param normalized: if True, the raw signal is first normalized
        :return: None
        &#34;&#34;&#34;
        if normalized:
            self.signal = self.raw_signal.normalize()
        else:
            self.signal = self.raw_signal

    def bin_divide(self):
        &#34;&#34;&#34;
        Calls the `.make_freq_bins` method of the signal to create the signals associated
        to the frequency bins. The bins are all stored in the `.bin` attribute and also as
        their names (Ex: `Sound.mid` contains the mid signal).
        :return: None
        &#34;&#34;&#34;
        &#34;&#34;&#34; a method to divide the main signal into frequency bins&#34;&#34;&#34;
        # divide in frequency bins
        self.bins = self.signal.make_freq_bins()
        # unpack the bins
        self.bass, self.mid, self.highmid, self.uppermid, self.presence, self.brillance = self.bins.values()

    def filter_noise(self, verbose=True):
        &#34;&#34;&#34;
        Filters the noise in the signal attribute
        :param verbose: if True problem are printed to the terminal
        :return: None
        &#34;&#34;&#34;
        # filter the noise in the Signal class
        self.signal = self.trimmed_signal.filter_noise(verbose=verbose)

    def trim_signal(self, verbose=True):
        &#34;&#34;&#34;
        A method to trim the signal to a specific time before the onset. The time value
        can be changed in the SoundParameters.
        :param verbose: if True problems encountered are printed to the terminal
        :return: None
        &#34;&#34;&#34;
        # Trim the signal in the signal class
        self.trimmed_signal = self.raw_signal.trim_onset(verbose=verbose)

    def listen_freq_bins(self):
        &#34;&#34;&#34;
        Method to listen to all the frequency bins of a sound

        The bins signals are obtained by filtering the sound signal
        with band pass filters.

        See guitarsounds.parameters.sound_parameters().bins.info() for the
        frequency bin intervals.
        &#34;&#34;&#34;
        for key in self.bins.keys():
            print(key)
            self.bins[key].normalize().listen()

    def plot_freq_bins(self, bins=None):
        &#34;&#34;&#34;
        Method to plot all the frequency bins logarithmic envelops of a sound

        The parameter `bins` allows choosing specific frequency bins to plot
        By default the function plots all the bins
        Supported bins arguments are :
        &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;

        Example :
        `Sound.plot_freq_bins(bins=[&#39;all])` plots all the frequency bins
        `Sound.plot_freq_bins(bins=[&#39;bass&#39;, &#39;mid&#39;])` plots the bass and mid bins
        &#34;&#34;&#34;
        try:
            value = bins[0]
            if value == &#39;all&#39;:
                bins = self.bins.keys()
        except TypeError:
            if bins is None:
                bins = self.bins.keys()

        for key in bins:
            lab = key + &#39; : &#39; + str(int(self.bins[key].range[0])) + &#39; - &#39; + str(int(self.bins[key].range[1])) + &#39; Hz&#39;
            self.bins[key].old_plot(&#39;log envelop&#39;, label=lab)

        plt.xscale(&#39;log&#39;)
        plt.yscale(&#39;log&#39;)
        plt.legend(fontsize=&#34;x-small&#34;)  # using a named size

    def peak_damping(self):
        &#34;&#34;&#34;
        Prints a table with peak damping values and peak frequency values

        The peaks are found with the `signal.peaks()` function and the damping
        values are computed with the half power bandwith method.
        &#34;&#34;&#34;
        peak_indexes = self.signal.peaks()
        frequencies = self.signal.fft_frequencies()[peak_indexes]
        damping = self.signal.peak_damping()
        table_data = np.array([frequencies, np.array(damping) * 100]).transpose()
        print(tabulate(table_data, headers=[&#39;Frequency (Hz)&#39;, &#39;Damping ratio (%)&#39;]))

    def bin_hist(self):
        &#34;&#34;&#34;
        Histogram of the frequency bin power

        frequency bin power is computed as the integral of the bin envelop.
        See guitarsounds.parameters.sound_parameters().bins.info() for the
        frequency bin intervals.
        &#34;&#34;&#34;
        # Compute the bin powers
        bin_strings = list(self.bins.keys())
        integral = []

        for f_bin in bin_strings:
            log_envelop, log_time = self.bins[f_bin].normalize().log_envelop()
            integral.append(scipy.integrate.trapezoid(log_envelop, log_time))

        # create the bar plotting vectors
        fig, ax = plt.subplots(figsize=(6, 6))

        x = np.arange(0, len(bin_strings))
        y = integral
        ax.bar(x, y, tick_label=list(bin_strings))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="guitarsounds.analysis.Sound.bin_divide"><code class="name flex">
<span>def <span class="ident">bin_divide</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls the <code>.make_freq_bins</code> method of the signal to create the signals associated
to the frequency bins. The bins are all stored in the <code>.bin</code> attribute and also as
their names (Ex: <code>Sound.mid</code> contains the mid signal).
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bin_divide(self):
    &#34;&#34;&#34;
    Calls the `.make_freq_bins` method of the signal to create the signals associated
    to the frequency bins. The bins are all stored in the `.bin` attribute and also as
    their names (Ex: `Sound.mid` contains the mid signal).
    :return: None
    &#34;&#34;&#34;
    &#34;&#34;&#34; a method to divide the main signal into frequency bins&#34;&#34;&#34;
    # divide in frequency bins
    self.bins = self.signal.make_freq_bins()
    # unpack the bins
    self.bass, self.mid, self.highmid, self.uppermid, self.presence, self.brillance = self.bins.values()</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Sound.bin_hist"><code class="name flex">
<span>def <span class="ident">bin_hist</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Histogram of the frequency bin power</p>
<p>frequency bin power is computed as the integral of the bin envelop.
See guitarsounds.parameters.sound_parameters().bins.info() for the
frequency bin intervals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bin_hist(self):
    &#34;&#34;&#34;
    Histogram of the frequency bin power

    frequency bin power is computed as the integral of the bin envelop.
    See guitarsounds.parameters.sound_parameters().bins.info() for the
    frequency bin intervals.
    &#34;&#34;&#34;
    # Compute the bin powers
    bin_strings = list(self.bins.keys())
    integral = []

    for f_bin in bin_strings:
        log_envelop, log_time = self.bins[f_bin].normalize().log_envelop()
        integral.append(scipy.integrate.trapezoid(log_envelop, log_time))

    # create the bar plotting vectors
    fig, ax = plt.subplots(figsize=(6, 6))

    x = np.arange(0, len(bin_strings))
    y = integral
    ax.bar(x, y, tick_label=list(bin_strings))</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Sound.condition"><code class="name flex">
<span>def <span class="ident">condition</span></span>(<span>self, verbose=True, return_self=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A method conditioning the Sound instance.
- Trimming to just before the onset
- Filtering the noise
:param verbose: if True problem with trimming and filtering are reported
:param return_self: If True the method returns the conditioned Sound instance
:return: a conditioned Sound instance if <code>return_self = True</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def condition(self, verbose=True, return_self=False):
    &#34;&#34;&#34;
    A method conditioning the Sound instance.
    - Trimming to just before the onset
    - Filtering the noise
    :param verbose: if True problem with trimming and filtering are reported
    :param return_self: If True the method returns the conditioned Sound instance
    :return: a conditioned Sound instance if `return_self = True`
    &#34;&#34;&#34;
    self.trim_signal(verbose=verbose)
    self.filter_noise(verbose=verbose)
    self.bin_divide()
    if self.fundamental is None:
        self.fundamental = self.signal.fundamental()
    self.plot = self.signal.plot
    if return_self:
        return self</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Sound.filter_noise"><code class="name flex">
<span>def <span class="ident">filter_noise</span></span>(<span>self, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Filters the noise in the signal attribute
:param verbose: if True problem are printed to the terminal
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_noise(self, verbose=True):
    &#34;&#34;&#34;
    Filters the noise in the signal attribute
    :param verbose: if True problem are printed to the terminal
    :return: None
    &#34;&#34;&#34;
    # filter the noise in the Signal class
    self.signal = self.trimmed_signal.filter_noise(verbose=verbose)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Sound.listen_freq_bins"><code class="name flex">
<span>def <span class="ident">listen_freq_bins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to listen to all the frequency bins of a sound</p>
<p>The bins signals are obtained by filtering the sound signal
with band pass filters.</p>
<p>See guitarsounds.parameters.sound_parameters().bins.info() for the
frequency bin intervals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listen_freq_bins(self):
    &#34;&#34;&#34;
    Method to listen to all the frequency bins of a sound

    The bins signals are obtained by filtering the sound signal
    with band pass filters.

    See guitarsounds.parameters.sound_parameters().bins.info() for the
    frequency bin intervals.
    &#34;&#34;&#34;
    for key in self.bins.keys():
        print(key)
        self.bins[key].normalize().listen()</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Sound.peak_damping"><code class="name flex">
<span>def <span class="ident">peak_damping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a table with peak damping values and peak frequency values</p>
<p>The peaks are found with the <code>signal.peaks()</code> function and the damping
values are computed with the half power bandwith method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_damping(self):
    &#34;&#34;&#34;
    Prints a table with peak damping values and peak frequency values

    The peaks are found with the `signal.peaks()` function and the damping
    values are computed with the half power bandwith method.
    &#34;&#34;&#34;
    peak_indexes = self.signal.peaks()
    frequencies = self.signal.fft_frequencies()[peak_indexes]
    damping = self.signal.peak_damping()
    table_data = np.array([frequencies, np.array(damping) * 100]).transpose()
    print(tabulate(table_data, headers=[&#39;Frequency (Hz)&#39;, &#39;Damping ratio (%)&#39;]))</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Sound.plot_freq_bins"><code class="name flex">
<span>def <span class="ident">plot_freq_bins</span></span>(<span>self, bins=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to plot all the frequency bins logarithmic envelops of a sound</p>
<p>The parameter <code>bins</code> allows choosing specific frequency bins to plot
By default the function plots all the bins
Supported bins arguments are :
'all', 'bass', 'mid', 'highmid', 'uppermid', 'presence', 'brillance'</p>
<p>Example :
<code>Sound.plot_freq_bins(bins=['all])</code> plots all the frequency bins
<code>Sound.plot_freq_bins(bins=['bass', 'mid'])</code> plots the bass and mid bins</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_freq_bins(self, bins=None):
    &#34;&#34;&#34;
    Method to plot all the frequency bins logarithmic envelops of a sound

    The parameter `bins` allows choosing specific frequency bins to plot
    By default the function plots all the bins
    Supported bins arguments are :
    &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;

    Example :
    `Sound.plot_freq_bins(bins=[&#39;all])` plots all the frequency bins
    `Sound.plot_freq_bins(bins=[&#39;bass&#39;, &#39;mid&#39;])` plots the bass and mid bins
    &#34;&#34;&#34;
    try:
        value = bins[0]
        if value == &#39;all&#39;:
            bins = self.bins.keys()
    except TypeError:
        if bins is None:
            bins = self.bins.keys()

    for key in bins:
        lab = key + &#39; : &#39; + str(int(self.bins[key].range[0])) + &#39; - &#39; + str(int(self.bins[key].range[1])) + &#39; Hz&#39;
        self.bins[key].old_plot(&#39;log envelop&#39;, label=lab)

    plt.xscale(&#39;log&#39;)
    plt.yscale(&#39;log&#39;)
    plt.legend(fontsize=&#34;x-small&#34;)  # using a named size</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Sound.trim_signal"><code class="name flex">
<span>def <span class="ident">trim_signal</span></span>(<span>self, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A method to trim the signal to a specific time before the onset. The time value
can be changed in the SoundParameters.
:param verbose: if True problems encountered are printed to the terminal
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trim_signal(self, verbose=True):
    &#34;&#34;&#34;
    A method to trim the signal to a specific time before the onset. The time value
    can be changed in the SoundParameters.
    :param verbose: if True problems encountered are printed to the terminal
    :return: None
    &#34;&#34;&#34;
    # Trim the signal in the signal class
    self.trimmed_signal = self.raw_signal.trim_onset(verbose=verbose)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.Sound.use_raw_signal"><code class="name flex">
<span>def <span class="ident">use_raw_signal</span></span>(<span>self, normalized=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigns the raw signal to the <code>signal</code> attribute of the Sound instance to
analyze it
:param normalized: if True, the raw signal is first normalized
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def use_raw_signal(self, normalized=False):
    &#34;&#34;&#34;
    Assigns the raw signal to the `signal` attribute of the Sound instance to
    analyze it
    :param normalized: if True, the raw signal is first normalized
    :return: None
    &#34;&#34;&#34;
    if normalized:
        self.signal = self.raw_signal.normalize()
    else:
        self.signal = self.raw_signal</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="guitarsounds.analysis.SoundPack"><code class="flex name class">
<span>class <span class="ident">SoundPack</span></span>
<span>(</span><span>*sounds, names=None, fundamentals=None, SoundParams=None, equalize_time=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to store and analyse multiple sounds
Some methods are only available for the case with two sounds</p>
<p>The SoundPack can be instantiated from existing Sound class instances, either in a list or as
multiple arguments</p>
<p>The class can also handle the creation of Sound class instances if the arguments are filenames,
either a list or multiple arguments.</p>
<p>If the number of Sound contained is equal to two, the SoundPack will be 'dual' and the associated methods
will be available</p>
<p>If it contains multiple sounds the SoundPack will be multiple and a reduced number of methods will work</p>
<p>A list of names as strings and fundamental frequencies can be specified when creating the SoundPack</p>
<p>If equalize_time is set to False, the contained sounds will not be trimmed to the same length.</p>
<p>Examples :</p>
<pre><code>Sound_Test = SoundPack('sounds/test1.wav', 'sounds/test2.wav', names=['A', 'B'], fundamentals = [134, 134])

sounds = [sound1, sound2, sound3, sound4, sound5] # instances of the Sound class
large_Test = SoundPack(sounds, names=['1', '2', '3', '4', '5'])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SoundPack(object):
    &#34;&#34;&#34;
    A class to store and analyse multiple sounds
    Some methods are only available for the case with two sounds
    &#34;&#34;&#34;

    def __init__(self, *sounds, names=None, fundamentals=None, SoundParams=None, equalize_time=True):
        &#34;&#34;&#34;
        The SoundPack can be instantiated from existing Sound class instances, either in a list or as
        multiple arguments

        The class can also handle the creation of Sound class instances if the arguments are filenames,
        either a list or multiple arguments.

        If the number of Sound contained is equal to two, the SoundPack will be &#39;dual&#39; and the associated methods
        will be available

        If it contains multiple sounds the SoundPack will be multiple and a reduced number of methods will work

        A list of names as strings and fundamental frequencies can be specified when creating the SoundPack

        If equalize_time is set to False, the contained sounds will not be trimmed to the same length.

        Examples :
        ```
        Sound_Test = SoundPack(&#39;sounds/test1.wav&#39;, &#39;sounds/test2.wav&#39;, names=[&#39;A&#39;, &#39;B&#39;], fundamentals = [134, 134])

        sounds = [sound1, sound2, sound3, sound4, sound5] # instances of the Sound class
        large_Test = SoundPack(sounds, names=[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;])
        ```
        &#34;&#34;&#34;
        # create a copy of the sound parameters
        if SoundParams is None:
            self.SP = SP
        else:
            self.SP = SoundParams

        # Check if the sounds argument is a list
        if type(sounds[0]) is list:
            sounds = sounds[0]  # unpack the list

        # Check for special case
        if len(sounds) == 2:
            # special case to compare two sounds
            self.kind = &#39;dual&#39;

        elif len(sounds) &gt; 1:
            # general case for multiple sounds
            self.kind = &#39;multiple&#39;

        if type(sounds[0]) is str:
            self.sounds_from_files(sounds, names=names, fundamentals=fundamentals)

        else:
            self.sounds = sounds
            # Assign a default value to names
            if names is None:
                names = [str(n) for n in np.arange(1, len(sounds) + 1)]
                for sound, n in zip(self.sounds, names):
                    sound.name = n

            # sound name defined in constructor
            elif names and (len(names) == len(self.sounds)):
                for sound, n in zip(self.sounds, names):
                    sound.name = n

        if equalize_time:
            self.equalize_time()

        # Define bin strings
        self.bin_strings = [*list(self.SP.bins.__dict__.keys())[1:], &#39;brillance&#39;]

        # Sort according to fundamental
        key = np.argsort([sound.fundamental for sound in self.sounds])
        self.sounds = np.array(self.sounds)[key]

    def sounds_from_files(self, sound_files, names=None, fundamentals=None):
        &#34;&#34;&#34;
        Create Sound class instances and assign them to the SoundPack from a list of files
        :param sound_files: sound filenames
        :param names: sound names
        :param fundamentals: user specified fundamental frequencies
        :return: None
        &#34;&#34;&#34;
        # Make the default name list from sound filenames if none is supplied
        if (names is None) or (len(names) != len(sound_files)):
            names = [file[:-4] for file in sound_files]  # remove the .wav

        # If the fundamentals are not supplied or mismatch in number None is used
        if (fundamentals is None) or (len(fundamentals) != len(sound_files)):
            fundamentals = len(sound_files) * [None]

        # Create Sound instances from files
        self.sounds = []
        for file, name, fundamental in zip(sound_files, names, fundamentals):
            self.sounds.append(Sound(file, name=name, fundamental=fundamental,
                                     SoundParams=self.SP).condition(return_self=True))

    def equalize_time(self):
        &#34;&#34;&#34;
        Trim the sounds so that they all have the length of the shortest sound, trimming is done at the end.
        :return: None
        &#34;&#34;&#34;
        trim_index = np.min([len(sound.signal.signal) for sound in self.sounds])
        trimmed_sounds = []
        for sound in self.sounds:
            new_sound = sound
            new_sound.signal = new_sound.signal.trim_time(trim_index / sound.signal.sr)
            new_sound.bin_divide()
            trimmed_sounds.append(new_sound)
        self.sounds = trimmed_sounds

    def normalize(self):
        &#34;&#34;&#34;
        Normalize all the signals in the SoundPack and returns a normaized
        instance of itself
        :return: SoundPack with normalized signals
        &#34;&#34;&#34;
        new_sounds = []
        names = [sound.name for sound in self.sounds]
        fundamentals = [sound.fundamental for sound in self.sounds]
        for sound in self.sounds:
            sound.signal = sound.signal.normalize()
            new_sounds.append(sound)

        return SoundPack(new_sounds, names=names, fundamentals=fundamentals, SoundParams=self.SP, equalize_time=False)

    &#34;&#34;&#34;
    Methods for all SoundPacks
    &#34;&#34;&#34;

    def plot(self, kind, **kwargs):
        &#34;&#34;&#34;
        Superimposed plot of all the sounds on one figure for a specific kind

        __ Multiple SoundPack Method __
        Plots a specific signal.plot for all sounds on the same figure
        Ex : compare_plot(&#39;fft&#39;) plots the fft of all sounds on a single figure
        The color argument is set to none so that the plots have different colors

        :param kind: Attribute passed to the `signal.plot()` method
        :param kwargs: key words arguments to pass to the `signal.plot()` method
        :return: None
        &#34;&#34;&#34;
        plt.figure(figsize=(8, 6))
        for sound in self.sounds:
            kwargs[&#39;label&#39;] = sound.name
            kwargs[&#39;color&#39;] = None
            sound.signal.old_plot(kind, **kwargs)

        plt.title(kind + &#39; plot&#39;)
        if kind == &#39;timbre&#39;:
            plt.legend(bbox_to_anchor=(1.3, 0.9))
        else:
            plt.legend()

    def compare_plot(self, kind, **kwargs):
        &#34;&#34;&#34;
        Plots all the sounds on different figures to compare them for a specific kind

        __ Multiple SoundPack Method __
        Draws the same kind of plot on a different axis for each sound
        Example : `SoundPack.compare_plot(&#39;peaks&#39;)` with 4 Sounds will plot a figure with 4 axes, with each
        a different &#39;peak&#39; plot.

        :param kind: kind argument passed to `Signal.plot()`
        :param kwargs: key word arguments passed to Signal.plot()
        :return: None
        &#34;&#34;&#34;
        # if a dual SoundPack : only plot two big plots
        if self.kind == &#39;dual&#39;:

            if kind == &#39;timbre&#39;:
                fig, axs = plt.subplots(1, 2, figsize=(8, 4), subplot_kw={&#39;projection&#39;: &#39;polar&#39;})
                for sound, ax in zip(self.sounds, axs):
                    plt.sca(ax)
                    sound.signal.old_plot(kind, **kwargs)
                    ax.set_title(kind + &#39; &#39; + sound.name)

            else:
                fig, axs = plt.subplots(1, 2, figsize=(12, 4))
                for sound, ax in zip(self.sounds, axs):
                    plt.sca(ax)
                    sound.signal.old_plot(kind, **kwargs)
                    ax.set_title(kind + &#39; &#39; + sound.name)
            plt.tight_layout()

        # If a multiple SoundPack : plot on a grid of axes
        elif self.kind == &#39;multiple&#39;:

            # find the n, m values for the subplots line and columns
            n = len(self.sounds)
            if n // 4 &gt;= 10:
                # a lot of sounds
                cols = 4
            elif n // 3 &gt;= 10:
                # many sounds
                cols = 3
            elif n // 2 &lt;= 4:
                # a few sounds
                cols = 2

            remainder = n % cols
            if remainder == 0:
                rows = n // cols
            else:
                rows = n // cols + 1

            fig, axs = plt.subplots(rows, cols, figsize=(12, 4 * rows))
            axs = axs.reshape(-1)
            for sound, ax in zip(self.sounds, axs):
                plt.sca(ax)
                sound.signal.old_plot(kind, **kwargs)
                title = ax.get_title()
                title = sound.name + &#39; &#39; + title
                ax.set_title(title)

            if remainder != 0:
                for ax in axs[-(cols - remainder):]:
                    ax.set_axis_off()

            plt.tight_layout()

    def freq_bin_plot(self, f_bin=&#39;all&#39;):
        &#34;&#34;&#34;
        Plots the log envelop of specified frequency bins

        __ Multiple SoundPack Method __
        A function to compare signals decomposed frequency wise in the time domain on a logarithm scale.
        The methods plots all the sounds and plots their frequency bins according to the frequency bin argument f_bin.

        Example : SoundPack.freq_bin_plot(f_bin=&#39;mid&#39;) will plot the log-scale envelop of the &#39;mid&#39; signal of every
        sound in the SoundPack

        f_bin: frequency bins to compare, Supported arguments are :
        &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
        &#34;&#34;&#34;

        if f_bin == &#39;all&#39;:
            # Create one plot per bin
            fig, axs = plt.subplots(3, 2, figsize=(12, 12))
            axs = axs.reshape(-1)
            for key, ax in zip([*list(self.SP.bins.__dict__.keys())[1:], &#39;brillance&#39;], axs):
                plt.sca(ax)
                # plot every sound for a frequency bin
                norm_factors = np.array([son.bins[key].normalize().norm_factor for son in self.sounds])
                for i, son in enumerate(self.sounds):
                    son.bins[key].normalize().old_plot(&#39;log envelop&#39;, label=son.name)
                plt.xscale(&#39;log&#39;)
                plt.legend()
                title0 = &#39; &#39; + key + &#39; : &#39; + str(int(son.bins[key].range[0])) + &#39; - &#39; + str(
                        int(son.bins[key].range[1])) + &#39; Hz, &#39;
                title1 = &#39;Norm. Factors : &#39;
                title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
                plt.title(title0 + title1 + title2)
            plt.tight_layout()

        elif f_bin in [*list(SP.bins.__dict__.keys())[1:], &#39;brillance&#39;]:
            plt.figure(figsize=(10, 4))
            # Plot every envelop for a single frequency bin
            norm_factors = np.array([son.bins[f_bin].normalize().norm_factor for son in self.sounds])
            for i, son in enumerate(self.sounds):
                son.bins[f_bin].normalize().old_plot(&#39;log envelop&#39;, label=(str(i + 1) + &#39;. &#39; + son.name))
            plt.xscale(&#39;log&#39;)
            plt.legend()
            title0 = &#39; &#39; + f_bin + &#39; : &#39; + str(int(son.bins[f_bin].range[0])) + &#39; - &#39; + str(
                int(son.bins[f_bin].range[1])) + &#39; Hz, &#39;
            title1 = &#39;Norm. Factors : &#39;
            title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
            plt.title(title0 + title1 + title2)

        else:
            print(&#39;invalid frequency bin&#39;)

    def combine_envelop(self, kind=&#39;signal&#39;, difference_factor=1, show_sounds=True, show_rejects=True, **kwargs):
        &#34;&#34;&#34;
        __ Multiple SoundPack Method __
        Combines the envelops of the Sounds contained in the SoundPack, Sounds having a too large difference factor
        from the average are rejected.

        :param kind: wich signal to use from :
        &#39;signal&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
        :param difference_factor: threshold to reject a sound from the combinaison, can be adjusted to reject
        or include more sounds.
        :param show_sounds: If True all the included Sounds are shown on the plot
        :param show_rejects: If True all the rejected Sounds are shown on the plot
        :param kwargs: Key word arguments to pass to the envelop plot.
        :return: None
        &#34;&#34;&#34;
        sounds = self.sounds
        sample_number = np.min([len(s1.signal.log_envelop()[0]) for s1 in sounds])

        if kind == &#39;signal&#39;:
            log_envelops = np.stack([s1.signal.normalize().log_envelop()[0][:sample_number] for s1 in sounds])
        elif kind in SP.bins.__dict__.keys():
            log_envelops = np.stack([s1.bins[kind].normalize().log_envelop()[0][:sample_number] for s1 in sounds])
        else:
            print(&#39;Wrong kind&#39;)

        average_log_envelop = np.mean(log_envelops, axis=0)
        means = np.tile(average_log_envelop, (len(sounds), 1))
        diffs = np.sum(np.abs(means - log_envelops), axis=1)
        diff = np.mean(diffs) * difference_factor

        good_sounds = np.array(sounds)[diffs &lt; diff]
        rejected_sounds = np.array(sounds)[diffs &gt; diff]
        average_log_envelop = np.mean(log_envelops[diffs &lt; diff], axis=0)
        norm_factors = np.array([s1.signal.normalize().norm_factor for s1 in good_sounds])

        if kind == &#39;signal&#39;:
            if show_sounds:
                for s1 in good_sounds[:-1]:
                    s1.signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;)
                sounds[-1].signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;, label=&#39;sounds&#39;)

            if show_rejects:
                if len(rejected_sounds) &gt; 1:
                    for s1 in rejected_sounds[:-1]:
                        s1.signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;)
                    rejected_sounds[-1].signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                                    label=&#39;rejected sounds&#39;)
                if len(rejected_sounds) == 1:
                    rejected_sounds[0].signal.normalize().plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                               label=&#39;rejected sounds&#39;)
            if len(good_sounds) &gt; 0:
                if &#39;label&#39; in kwargs.keys():
                    plt.plot(good_sounds[0].signal.log_envelop()[1][:len(average_log_envelop)], average_log_envelop,
                             **kwargs)
                else:
                    plt.plot(good_sounds[0].signal.log_envelop()[1][:len(average_log_envelop)], average_log_envelop,
                             label=&#39;average&#39;, color=&#39;k&#39;, **kwargs)

        else:
            if show_sounds:
                for s1 in good_sounds[:-1]:
                    s1.bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;)
                sounds[-1].bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;, label=&#39;sounds&#39;)

            if show_rejects:
                if len(rejected_sounds) &gt; 1:
                    for s2 in rejected_sounds[:-1]:
                        s2.bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;)
                    rejected_sounds[-1].bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                                        label=&#39;rejected sounds&#39;)
                if len(rejected_sounds) == 1:
                    rejected_sounds.bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                                    label=&#39;rejected sounds&#39;)

            plt.plot(good_sounds[0].signal.log_envelop()[1][:sample_number], average_log_envelop, color=&#39;k&#39;, **kwargs)

        plt.xlabel(&#39;time (s)&#39;)
        plt.ylabel(&#39;Amplitude&#39;)
        plt.legend()
        plt.xscale(&#39;log&#39;)
        print(&#39;Number of rejected sounds : &#39; + str(len(rejected_sounds)))
        print(&#39;Number of sounds included : &#39; + str(len(good_sounds)))
        print(&#39;Maximum normalisation factor : &#39; + str(np.around(np.max(norm_factors), 0)) + &#39;x&#39;)
        print(&#39;Minimum normalisation factor : &#39; + str(np.around(np.min(norm_factors), 0)) + &#39;x&#39;)

    def fundamentals(self):
        &#34;&#34;&#34;
        __ Multiple Soundpack Method __
        Displays the fundamentals of every sound in the SoundPack
        :return: None
        &#34;&#34;&#34;
        names = np.array([sound.name for sound in self.sounds])
        fundamentals = np.array([np.around(sound.fundamental, 1) for sound in self.sounds])
        key = np.argsort(fundamentals)
        table_data = [names[key], fundamentals[key]]

        table_data = np.array(table_data).transpose()

        print(tabulate(table_data, headers=[&#39;Name&#39;, &#39;Fundamental (Hz)&#39;]))

    def integral_plot(self, f_bin=&#39;all&#39;):
        &#34;&#34;&#34;
        Normalized cumulative bin power plot for the frequency bins

        __ Multiple SoundPack Method __
        Plots the cumulative integral plot of specified frequency bins
        see help(Plot.integral)

        f_bin: frequency bins to compare, Supported arguments are :
        &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
        &#34;&#34;&#34;

        if f_bin == &#39;all&#39;:
            # create a figure with 6 axes
            fig, axs = plt.subplots(3, 2, figsize=(12, 12))
            axs = axs.reshape(-1)

            for key, ax in zip(self.bin_strings, axs):
                plt.sca(ax)
                norm_factors = np.array([son.bins[key].normalize().norm_factor for son in self.sounds])
                for sound in self.sounds:
                    sound.bins[key].plot.integral(label=sound.name)
                plt.legend()
                title0 = &#39; &#39; + key + &#39; : &#39; + str(int(sound.bins[key].range[0])) + &#39; - &#39; + str(
                    int(sound.bins[key].range[1])) + &#39; Hz, &#39;
                title1 = &#39;Norm. Factors : &#39;
                title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
                plt.title(title0 + title1 + title2)
                plt.title(title0 + title1 + title2)
            plt.tight_layout()

        elif f_bin in self.bin_strings:
            fig, ax = plt.subplots(figsize=(6, 4))
            plt.sca(ax)
            norm_factors = np.array([son.bins[f_bin].normalize().norm_factor for son in self.sounds])
            for sound in self.sounds:
                sound.bins[f_bin].plot.integral(label=sound.name)
            plt.legend()
            title0 = &#39; &#39; + f_bin + &#39; : &#39; + str(int(sound.bins[f_bin].range[0])) + &#39; - &#39; + str(
                int(sound.bins[f_bin].range[1])) + &#39; Hz, &#39;
            title1 = &#39;Norm. Factors : &#39;
            title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
            plt.title(title0 + title1 + title2)

        else:
            print(&#39;invalid frequency bin&#39;)
            
    def bin_power_table(self):
        &#34;&#34;&#34;
        Displays a table with the signal power contained in every frequency bin
        
        The power is computed as the time integral of the signal
        &#34;&#34;&#34;
        # Bin power distribution table
        bin_strings = self.bin_strings
        integrals = []

        # for every sound in the SoundPack
        for sound in self.sounds:

            integral = []
            # for every frequency bin in the sound
            for f_bin in bin_strings:
                log_envelop, log_time = sound.bins[f_bin].normalize().log_envelop()
                integral.append(scipy.integrate.trapezoid(log_envelop, log_time))

            # a list of dict for every sound
            integrals.append(integral)

        # make the table
        table_data = np.array([list(bin_strings), *integrals]).transpose()
        sound_names = [sound.name for sound in self.sounds]

        print(&#39;___ Signal Power Frequency Bin Distribution ___ \n&#39;)
        print(tabulate(table_data, headers=[&#39;bin&#39;, *sound_names]))

    def bin_power_hist(self):
        &#34;&#34;&#34;
        Histogram of the frequency bin power for multiple sounds

        frequency bin power is computed as the integral of the bin envelop
        &#34;&#34;&#34;
        # Compute the bin powers
        bin_strings = self.bin_strings
        integrals = []

        # for every sound in the SoundPack
        for sound in self.sounds:

            integral = []
            # for every frequency bin in the sound
            for f_bin in bin_strings:
                log_envelop, log_time = sound.bins[f_bin].normalize().log_envelop()
                integral.append(scipy.integrate.trapezoid(log_envelop, log_time))

            # a list of dict for every sound
            integrals.append(integral)

        # create the bar plotting vectors
        fig, ax = plt.subplots(figsize=(6, 6))

        # make the bar plot
        n = len(self.sounds)
        width = 0.8 / n
        # get nice colors
        cmap = matplotlib.cm.get_cmap(&#39;Set2&#39;)
        for i, sound in enumerate(self.sounds):
            x = np.arange(i * width, len(bin_strings) + i * width)
            y = integrals[i]
            if n &lt; 8:
                color = cmap(i)
            else:
                color = None

            if i == n // 2:
                ax.bar(x, y, width=width, tick_label=list(bin_strings), label=sound.name, color=color)
            else:
                ax.bar(x, y, width=width, label=sound.name, color=color)
        plt.legend()

    &#34;&#34;&#34;
    Methods for dual SoundPacks
    &#34;&#34;&#34;

    def compare_peaks(self):
        &#34;&#34;&#34;
        Plot to compare the FFT peaks values of two sounds

        __ Dual SoundPack Method __
        Compares the peaks in the Fourier Transform of two Sounds,
        the peak with the highest difference is highlighted
        &#34;&#34;&#34;
        if self.kind == &#39;dual&#39;:
            son1 = self.sounds[0]
            son2 = self.sounds[1]
            index1 = np.where(son1.signal.fft_frequencies() &gt; self.SP.general.fft_range.value)[0][0]
            index2 = np.where(son2.signal.fft_frequencies() &gt; self.SP.general.fft_range.value)[0][0]

            # Get the peak data from the sounds
            peaks1 = son1.signal.peaks()
            peaks2 = son2.signal.peaks()
            freq1 = son1.signal.fft_frequencies()[:index1]
            freq2 = son2.signal.fft_frequencies()[:index2]
            fft1 = son1.signal.fft()[:index1]
            fft2 = son2.signal.fft()[:index2]

            peak_distance1 = np.mean([freq1[peaks1[i]] - freq1[peaks1[i + 1]] for i in range(len(peaks1) - 1)]) / 4
            peak_distance2 = np.mean([freq2[peaks2[i]] - freq2[peaks2[i + 1]] for i in range(len(peaks2) - 1)]) / 4
            peak_distance = np.abs(np.mean([peak_distance1, peak_distance2]))

            # Align  the two peak vectors
            new_peaks1 = []
            new_peaks2 = []
            for peak1 in peaks1:
                for peak2 in peaks2:
                    if np.abs(freq1[peak1] - freq2[peak2]) &lt; peak_distance:
                        new_peaks1.append(peak1)
                        new_peaks2.append(peak2)
            new_peaks1 = np.unique(np.array(new_peaks1))
            new_peaks2 = np.unique(np.array(new_peaks2))

            different_peaks1 = []
            different_peaks2 = []
            difference_threshold = 0.5
            while len(different_peaks1) &lt; 1:
                for peak1, peak2 in zip(new_peaks1, new_peaks2):
                    if np.abs(fft1[peak1] - fft2[peak2]) &gt; difference_threshold:
                        different_peaks1.append(peak1)
                        different_peaks2.append(peak2)
                difference_threshold -= 0.01

            # Plot the output
            plt.figure(figsize=(10, 6))
            plt.yscale(&#39;symlog&#39;, linthresh=10e-1)

            # Sound 1
            plt.plot(freq1, fft1, color=&#39;#919191&#39;, label=son1.name)
            plt.scatter(freq1[new_peaks1], fft1[new_peaks1], color=&#39;b&#39;, label=&#39;peaks&#39;)
            plt.scatter(freq1[different_peaks1], fft1[different_peaks1], color=&#39;g&#39;, label=&#39;diff peaks&#39;)
            annotation_string = &#39;Peaks with &#39; + str(np.around(difference_threshold, 2)) + &#39; difference&#39;
            plt.annotate(annotation_string, (freq1[different_peaks1[0]] + peak_distance / 2, fft1[different_peaks1[0]]))

            # Sound2
            plt.plot(freq2, -fft2, color=&#39;#3d3d3d&#39;, label=son2.name)
            plt.scatter(freq2[new_peaks2], -fft2[new_peaks2], color=&#39;b&#39;)
            plt.scatter(freq2[different_peaks2], -fft2[different_peaks2], color=&#39;g&#39;)
            plt.title(&#39;Fourier Transform Peak Analysis for &#39; + son1.name + &#39; and &#39; + son2.name)
            plt.grid(&#39;on&#39;)
            plt.legend()
        else:
            print(&#39;Unsupported for multiple sounds SoundPacks&#39;)

    def fft_mirror(self):
        &#34;&#34;&#34;
        Plot the Fourier Transforms of two sounds on opposed axis to compare the spectras

        __ Dual SoundPack Method __
        The fourier transforms are normalized between 0 and [-1, 1], the y scale is logarithmic
        :return: None
        &#34;&#34;&#34;
        if self.kind == &#39;dual&#39;:
            son1 = self.sounds[0]
            son2 = self.sounds[1]
            index = np.where(son1.signal.fft_frequencies() &gt; SP.general.fft_range.value)[0][0]

            plt.figure(figsize=(10, 6))
            plt.yscale(&#39;symlog&#39;)
            plt.grid(&#39;on&#39;)
            plt.plot(son1.signal.fft_frequencies()[:index], son1.signal.fft()[:index], label=son1.name)
            plt.plot(son2.signal.fft_frequencies()[:index], -son2.signal.fft()[:index], label=son2.name)
            plt.xlabel(&#39;Fréquence (Hz)&#39;)
            plt.ylabel(&#39;Amplitude&#39;)
            plt.title(&#39;Mirror Fourier Transform for &#39; + son1.name + &#39; and &#39; + son2.name)
            plt.legend()

        else:
            print(&#39;Unsupported for multiple sounds SoundPacks&#39;)

    def fft_diff(self, fraction=3, ticks=None):
        &#34;&#34;&#34;
        Plot the difference between the spectral distribution in the two sounds

        __ Dual SoundPack Method __
        Compare the Fourier Transform of two sounds by computing the differences of the octave bins heights.
        The two FTs are superimposed on the first plot to show differences
        The difference between the two FTs is plotted on the second plot

        :param fraction: octave fraction value used to compute the frequency bins A higher number will show
        a more precise comparison, but conclusions may be harder to draw.
        :param ticks:  If True the frequency bins intervals are used as X axis ticks
        :return: None
        &#34;&#34;&#34;
        if self.kind == &#39;dual&#39;:
            # Separate the sounds
            son1 = self.sounds[0]
            son2 = self.sounds[1]

            # Compute plotting bins
            x_values = utils.octave_values(fraction)
            hist_bins = utils.octave_histogram(fraction)
            bar_widths = np.array([hist_bins[i + 1] - hist_bins[i] for i in range(0, len(hist_bins) - 1)])

            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
            plot1 = ax1.hist(son1.signal.fft_bins(), utils.octave_histogram(fraction), color=&#39;blue&#39;, alpha=0.6,
                             label=son1.name)
            plot2 = ax1.hist(son2.signal.fft_bins(), utils.octave_histogram(fraction), color=&#39;orange&#39;, alpha=0.6,
                             label=son2.name)
            ax1.set_title(&#39;FT Histogram for &#39; + son1.name + &#39; and &#39; + son2.name)
            ax1.set_xscale(&#39;log&#39;)
            ax1.set_xlabel(&#39;Fréquence (Hz)&#39;)
            ax1.set_ylabel(&#39;Amplitude&#39;)
            ax1.grid(&#39;on&#39;)
            ax1.legend()

            diff = plot1[0] - plot2[0]
            n_index = np.where(diff &lt;= 0)[0]
            p_index = np.where(diff &gt;= 0)[0]

            # Negative difference corresponding to sound 2
            ax2.bar(x_values[n_index], diff[n_index], width=bar_widths[n_index], color=&#39;orange&#39;, alpha=0.6)
            # Positive difference corresponding to sound1
            ax2.bar(x_values[p_index], diff[p_index], width=bar_widths[p_index], color=&#39;blue&#39;, alpha=0.6)
            ax2.set_title(&#39;Difference &#39; + son1.name + &#39; - &#39; + son2.name)
            ax2.set_xscale(&#39;log&#39;)
            ax2.set_xlabel(&#39;Fréquence (Hz)&#39;)
            ax2.set_ylabel(&#39;&lt;- Son 2 : Son 1 -&gt;&#39;)
            ax2.grid(&#39;on&#39;)

            if ticks == &#39;bins&#39;:
                labels = [label for label in self.SP.bins.__dict__ if label != &#39;name&#39;]
                labels.append(&#39;brillance&#39;)
                x = [param.value for param in self.SP.bins.__dict__.values() if param != &#39;bins&#39;]
                x.append(11250)
                x_formatter = ticker.FixedFormatter(labels)
                x_locator = ticker.FixedLocator(x)
                ax1.xaxis.set_major_locator(x_locator)
                ax1.xaxis.set_major_formatter(x_formatter)
                ax1.tick_params(axis=&#34;x&#34;, labelrotation=90)
                ax2.xaxis.set_major_locator(x_locator)
                ax2.xaxis.set_major_formatter(x_formatter)
                ax2.tick_params(axis=&#34;x&#34;, labelrotation=90)

        else:
            print(&#39;Unsupported for multiple sounds SoundPacks&#39;)

    def integral_compare(self, f_bin=&#39;all&#39;):
        &#34;&#34;&#34;
          Cumulative bin envelop integral comparison for two signals

          __ Dual SoundPack Method __
          Plots the cumulative integral plot of specified frequency bins
          and their difference as surfaces

          f_bin: frequency bins to compare, Supported arguments are :
          &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
          &#34;&#34;&#34;

        # Case when plotting all the frequency bins
        if f_bin == &#39;all&#39;:
            fig, axs = plt.subplots(3, 2, figsize=(16, 16))
            axs = axs.reshape(-1)

            self.bin_strings = self.sounds[0].bins.keys()
            bins1 = self.sounds[0].bins.values()
            bins2 = self.sounds[1].bins.values()

            for signal1, signal2, bin_string, ax in zip(bins1, bins2, self.bin_strings, axs):
                log_envelop1, log_time1 = signal1.normalize().log_envelop()
                log_envelop2, log_time2 = signal2.normalize().log_envelop()
                integ = scipy.integrate.trapezoid

                integral1 = np.array([integ(log_envelop1[:i], log_time1[:i]) for i in np.arange(2, len(log_envelop1), 1)])
                integral2 = np.array([integ(log_envelop2[:i], log_time2[:i]) for i in np.arange(2, len(log_envelop2), 1)])
                time1 = log_time1[2:len(log_time1):1]
                time2 = log_time2[2:len(log_time2):1]

                int_index = np.min([integral1.shape[0], integral2.shape[0]])
                ax.fill_between(time1, integral1, label=self.sounds[0].name, alpha=0.4)
                ax.fill_between(time2, -integral2, label=self.sounds[1].name, alpha=0.4)
                ax.fill_between(time2, integral1 - integral2, color=&#39;g&#39;, label=&#39;int diff&#39;, alpha=0.6)

                ax.set_xlabel(&#39;time (s)&#39;)
                ax.set_ylabel(&#39;cummulative power&#39;)
                ax.set_xscale(&#39;log&#39;)
                ax.set_title(bin_string)
                ax.legend()
                ax.grid(&#39;on&#39;)
            plt.tight_layout()

        elif f_bin in self.bin_strings:
            fig, ax = plt.subplots(figsize=(8, 6))
            signal1 = self.sounds[0].bins[f_bin]
            signal2 = self.sounds[1].bins[f_bin]
            log_envelop1, log_time1 = signal1.normalize().log_envelop()
            log_envelop2, log_time2 = signal2.normalize().log_envelop()
            integ = scipy.integrate.trapezoid

            integral1 = np.array([integ(log_envelop1[:i], log_time1[:i]) for i in np.arange(2, len(log_envelop1), 1)])
            integral2 = np.array([integ(log_envelop2[:i], log_time2[:i]) for i in np.arange(2, len(log_envelop2), 1)])
            time1 = log_time1[2:len(log_time1):1]
            time2 = log_time2[2:len(log_time2):1]

            int_index = np.min([integral1.shape[0], integral2.shape[0]])
            ax.fill_between(time1, integral1, label=self.sounds[0].name, alpha=0.4)
            ax.fill_between(time2, -integral2, label=self.sounds[1].name, alpha=0.4)
            ax.fill_between(time2, integral1 - integral2, color=&#39;g&#39;, label=&#39;int diff&#39;, alpha=0.6)

            ax.set_xlabel(&#39;time (s)&#39;)
            ax.set_ylabel(&#39;cummulative power&#39;)
            ax.set_xscale(&#39;log&#39;)
            ax.set_title(f_bin)
            ax.legend(loc=&#39;upper left&#39;)
            ax.grid(&#39;on&#39;)

        else:
            print(&#39;invalid frequency bin&#39;)

    def coherence_plot(self):
        &#34;&#34;&#34;
        __ Dual SoundPack Method __
        computes and plots the coherence between the time signal of two Sounds
        :return: None
        &#34;&#34;&#34;
        if self.kind == &#39;dual&#39;:
            f, C = sig.coherence(self.sounds[0].signal.signal, self.sounds[1].signal.signal, self.sounds[0].signal.sr)
            plt.plot(f, C, color=&#39;b&#39;)
            plt.yscale(&#39;log&#39;)
            plt.xlabel(&#39;Fréquence (Hz)&#39;)
            plt.ylabel(&#39;Coherence [0, 1]&#39;)
            title = &#39;Cohérence entre les sons &#39; + self.sounds[0].name + &#39; et &#39; + self.sounds[1].name
            plt.title(title)
        else:
            print(&#39;Unsupported for multiple sounds SoundPacks&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="guitarsounds.analysis.SoundPack.bin_power_hist"><code class="name flex">
<span>def <span class="ident">bin_power_hist</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Histogram of the frequency bin power for multiple sounds</p>
<p>frequency bin power is computed as the integral of the bin envelop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bin_power_hist(self):
    &#34;&#34;&#34;
    Histogram of the frequency bin power for multiple sounds

    frequency bin power is computed as the integral of the bin envelop
    &#34;&#34;&#34;
    # Compute the bin powers
    bin_strings = self.bin_strings
    integrals = []

    # for every sound in the SoundPack
    for sound in self.sounds:

        integral = []
        # for every frequency bin in the sound
        for f_bin in bin_strings:
            log_envelop, log_time = sound.bins[f_bin].normalize().log_envelop()
            integral.append(scipy.integrate.trapezoid(log_envelop, log_time))

        # a list of dict for every sound
        integrals.append(integral)

    # create the bar plotting vectors
    fig, ax = plt.subplots(figsize=(6, 6))

    # make the bar plot
    n = len(self.sounds)
    width = 0.8 / n
    # get nice colors
    cmap = matplotlib.cm.get_cmap(&#39;Set2&#39;)
    for i, sound in enumerate(self.sounds):
        x = np.arange(i * width, len(bin_strings) + i * width)
        y = integrals[i]
        if n &lt; 8:
            color = cmap(i)
        else:
            color = None

        if i == n // 2:
            ax.bar(x, y, width=width, tick_label=list(bin_strings), label=sound.name, color=color)
        else:
            ax.bar(x, y, width=width, label=sound.name, color=color)
    plt.legend()</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.bin_power_table"><code class="name flex">
<span>def <span class="ident">bin_power_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a table with the signal power contained in every frequency bin</p>
<p>The power is computed as the time integral of the signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bin_power_table(self):
    &#34;&#34;&#34;
    Displays a table with the signal power contained in every frequency bin
    
    The power is computed as the time integral of the signal
    &#34;&#34;&#34;
    # Bin power distribution table
    bin_strings = self.bin_strings
    integrals = []

    # for every sound in the SoundPack
    for sound in self.sounds:

        integral = []
        # for every frequency bin in the sound
        for f_bin in bin_strings:
            log_envelop, log_time = sound.bins[f_bin].normalize().log_envelop()
            integral.append(scipy.integrate.trapezoid(log_envelop, log_time))

        # a list of dict for every sound
        integrals.append(integral)

    # make the table
    table_data = np.array([list(bin_strings), *integrals]).transpose()
    sound_names = [sound.name for sound in self.sounds]

    print(&#39;___ Signal Power Frequency Bin Distribution ___ \n&#39;)
    print(tabulate(table_data, headers=[&#39;bin&#39;, *sound_names]))</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.coherence_plot"><code class="name flex">
<span>def <span class="ident">coherence_plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Dual SoundPack Method </strong>
computes and plots the coherence between the time signal of two Sounds
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coherence_plot(self):
    &#34;&#34;&#34;
    __ Dual SoundPack Method __
    computes and plots the coherence between the time signal of two Sounds
    :return: None
    &#34;&#34;&#34;
    if self.kind == &#39;dual&#39;:
        f, C = sig.coherence(self.sounds[0].signal.signal, self.sounds[1].signal.signal, self.sounds[0].signal.sr)
        plt.plot(f, C, color=&#39;b&#39;)
        plt.yscale(&#39;log&#39;)
        plt.xlabel(&#39;Fréquence (Hz)&#39;)
        plt.ylabel(&#39;Coherence [0, 1]&#39;)
        title = &#39;Cohérence entre les sons &#39; + self.sounds[0].name + &#39; et &#39; + self.sounds[1].name
        plt.title(title)
    else:
        print(&#39;Unsupported for multiple sounds SoundPacks&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.combine_envelop"><code class="name flex">
<span>def <span class="ident">combine_envelop</span></span>(<span>self, kind='signal', difference_factor=1, show_sounds=True, show_rejects=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Multiple SoundPack Method </strong>
Combines the envelops of the Sounds contained in the SoundPack, Sounds having a too large difference factor
from the average are rejected.</p>
<p>:param kind: wich signal to use from :
'signal', 'bass', 'mid', 'highmid', 'uppermid', 'presence', 'brillance'
:param difference_factor: threshold to reject a sound from the combinaison, can be adjusted to reject
or include more sounds.
:param show_sounds: If True all the included Sounds are shown on the plot
:param show_rejects: If True all the rejected Sounds are shown on the plot
:param kwargs: Key word arguments to pass to the envelop plot.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_envelop(self, kind=&#39;signal&#39;, difference_factor=1, show_sounds=True, show_rejects=True, **kwargs):
    &#34;&#34;&#34;
    __ Multiple SoundPack Method __
    Combines the envelops of the Sounds contained in the SoundPack, Sounds having a too large difference factor
    from the average are rejected.

    :param kind: wich signal to use from :
    &#39;signal&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
    :param difference_factor: threshold to reject a sound from the combinaison, can be adjusted to reject
    or include more sounds.
    :param show_sounds: If True all the included Sounds are shown on the plot
    :param show_rejects: If True all the rejected Sounds are shown on the plot
    :param kwargs: Key word arguments to pass to the envelop plot.
    :return: None
    &#34;&#34;&#34;
    sounds = self.sounds
    sample_number = np.min([len(s1.signal.log_envelop()[0]) for s1 in sounds])

    if kind == &#39;signal&#39;:
        log_envelops = np.stack([s1.signal.normalize().log_envelop()[0][:sample_number] for s1 in sounds])
    elif kind in SP.bins.__dict__.keys():
        log_envelops = np.stack([s1.bins[kind].normalize().log_envelop()[0][:sample_number] for s1 in sounds])
    else:
        print(&#39;Wrong kind&#39;)

    average_log_envelop = np.mean(log_envelops, axis=0)
    means = np.tile(average_log_envelop, (len(sounds), 1))
    diffs = np.sum(np.abs(means - log_envelops), axis=1)
    diff = np.mean(diffs) * difference_factor

    good_sounds = np.array(sounds)[diffs &lt; diff]
    rejected_sounds = np.array(sounds)[diffs &gt; diff]
    average_log_envelop = np.mean(log_envelops[diffs &lt; diff], axis=0)
    norm_factors = np.array([s1.signal.normalize().norm_factor for s1 in good_sounds])

    if kind == &#39;signal&#39;:
        if show_sounds:
            for s1 in good_sounds[:-1]:
                s1.signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;)
            sounds[-1].signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;, label=&#39;sounds&#39;)

        if show_rejects:
            if len(rejected_sounds) &gt; 1:
                for s1 in rejected_sounds[:-1]:
                    s1.signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;)
                rejected_sounds[-1].signal.normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                                label=&#39;rejected sounds&#39;)
            if len(rejected_sounds) == 1:
                rejected_sounds[0].signal.normalize().plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                           label=&#39;rejected sounds&#39;)
        if len(good_sounds) &gt; 0:
            if &#39;label&#39; in kwargs.keys():
                plt.plot(good_sounds[0].signal.log_envelop()[1][:len(average_log_envelop)], average_log_envelop,
                         **kwargs)
            else:
                plt.plot(good_sounds[0].signal.log_envelop()[1][:len(average_log_envelop)], average_log_envelop,
                         label=&#39;average&#39;, color=&#39;k&#39;, **kwargs)

    else:
        if show_sounds:
            for s1 in good_sounds[:-1]:
                s1.bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;)
            sounds[-1].bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.2, color=&#39;k&#39;, label=&#39;sounds&#39;)

        if show_rejects:
            if len(rejected_sounds) &gt; 1:
                for s2 in rejected_sounds[:-1]:
                    s2.bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;)
                rejected_sounds[-1].bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                                    label=&#39;rejected sounds&#39;)
            if len(rejected_sounds) == 1:
                rejected_sounds.bins[kind].normalize().old_plot(kind=&#39;log envelop&#39;, alpha=0.3, color=&#39;r&#39;,
                                                                label=&#39;rejected sounds&#39;)

        plt.plot(good_sounds[0].signal.log_envelop()[1][:sample_number], average_log_envelop, color=&#39;k&#39;, **kwargs)

    plt.xlabel(&#39;time (s)&#39;)
    plt.ylabel(&#39;Amplitude&#39;)
    plt.legend()
    plt.xscale(&#39;log&#39;)
    print(&#39;Number of rejected sounds : &#39; + str(len(rejected_sounds)))
    print(&#39;Number of sounds included : &#39; + str(len(good_sounds)))
    print(&#39;Maximum normalisation factor : &#39; + str(np.around(np.max(norm_factors), 0)) + &#39;x&#39;)
    print(&#39;Minimum normalisation factor : &#39; + str(np.around(np.min(norm_factors), 0)) + &#39;x&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.compare_peaks"><code class="name flex">
<span>def <span class="ident">compare_peaks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot to compare the FFT peaks values of two sounds</p>
<p><strong> Dual SoundPack Method </strong>
Compares the peaks in the Fourier Transform of two Sounds,
the peak with the highest difference is highlighted</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_peaks(self):
    &#34;&#34;&#34;
    Plot to compare the FFT peaks values of two sounds

    __ Dual SoundPack Method __
    Compares the peaks in the Fourier Transform of two Sounds,
    the peak with the highest difference is highlighted
    &#34;&#34;&#34;
    if self.kind == &#39;dual&#39;:
        son1 = self.sounds[0]
        son2 = self.sounds[1]
        index1 = np.where(son1.signal.fft_frequencies() &gt; self.SP.general.fft_range.value)[0][0]
        index2 = np.where(son2.signal.fft_frequencies() &gt; self.SP.general.fft_range.value)[0][0]

        # Get the peak data from the sounds
        peaks1 = son1.signal.peaks()
        peaks2 = son2.signal.peaks()
        freq1 = son1.signal.fft_frequencies()[:index1]
        freq2 = son2.signal.fft_frequencies()[:index2]
        fft1 = son1.signal.fft()[:index1]
        fft2 = son2.signal.fft()[:index2]

        peak_distance1 = np.mean([freq1[peaks1[i]] - freq1[peaks1[i + 1]] for i in range(len(peaks1) - 1)]) / 4
        peak_distance2 = np.mean([freq2[peaks2[i]] - freq2[peaks2[i + 1]] for i in range(len(peaks2) - 1)]) / 4
        peak_distance = np.abs(np.mean([peak_distance1, peak_distance2]))

        # Align  the two peak vectors
        new_peaks1 = []
        new_peaks2 = []
        for peak1 in peaks1:
            for peak2 in peaks2:
                if np.abs(freq1[peak1] - freq2[peak2]) &lt; peak_distance:
                    new_peaks1.append(peak1)
                    new_peaks2.append(peak2)
        new_peaks1 = np.unique(np.array(new_peaks1))
        new_peaks2 = np.unique(np.array(new_peaks2))

        different_peaks1 = []
        different_peaks2 = []
        difference_threshold = 0.5
        while len(different_peaks1) &lt; 1:
            for peak1, peak2 in zip(new_peaks1, new_peaks2):
                if np.abs(fft1[peak1] - fft2[peak2]) &gt; difference_threshold:
                    different_peaks1.append(peak1)
                    different_peaks2.append(peak2)
            difference_threshold -= 0.01

        # Plot the output
        plt.figure(figsize=(10, 6))
        plt.yscale(&#39;symlog&#39;, linthresh=10e-1)

        # Sound 1
        plt.plot(freq1, fft1, color=&#39;#919191&#39;, label=son1.name)
        plt.scatter(freq1[new_peaks1], fft1[new_peaks1], color=&#39;b&#39;, label=&#39;peaks&#39;)
        plt.scatter(freq1[different_peaks1], fft1[different_peaks1], color=&#39;g&#39;, label=&#39;diff peaks&#39;)
        annotation_string = &#39;Peaks with &#39; + str(np.around(difference_threshold, 2)) + &#39; difference&#39;
        plt.annotate(annotation_string, (freq1[different_peaks1[0]] + peak_distance / 2, fft1[different_peaks1[0]]))

        # Sound2
        plt.plot(freq2, -fft2, color=&#39;#3d3d3d&#39;, label=son2.name)
        plt.scatter(freq2[new_peaks2], -fft2[new_peaks2], color=&#39;b&#39;)
        plt.scatter(freq2[different_peaks2], -fft2[different_peaks2], color=&#39;g&#39;)
        plt.title(&#39;Fourier Transform Peak Analysis for &#39; + son1.name + &#39; and &#39; + son2.name)
        plt.grid(&#39;on&#39;)
        plt.legend()
    else:
        print(&#39;Unsupported for multiple sounds SoundPacks&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.compare_plot"><code class="name flex">
<span>def <span class="ident">compare_plot</span></span>(<span>self, kind, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots all the sounds on different figures to compare them for a specific kind</p>
<p><strong> Multiple SoundPack Method </strong>
Draws the same kind of plot on a different axis for each sound
Example : <code>SoundPack.compare_plot('peaks')</code> with 4 Sounds will plot a figure with 4 axes, with each
a different 'peak' plot.</p>
<p>:param kind: kind argument passed to <code>Signal.plot()</code>
:param kwargs: key word arguments passed to Signal.plot()
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_plot(self, kind, **kwargs):
    &#34;&#34;&#34;
    Plots all the sounds on different figures to compare them for a specific kind

    __ Multiple SoundPack Method __
    Draws the same kind of plot on a different axis for each sound
    Example : `SoundPack.compare_plot(&#39;peaks&#39;)` with 4 Sounds will plot a figure with 4 axes, with each
    a different &#39;peak&#39; plot.

    :param kind: kind argument passed to `Signal.plot()`
    :param kwargs: key word arguments passed to Signal.plot()
    :return: None
    &#34;&#34;&#34;
    # if a dual SoundPack : only plot two big plots
    if self.kind == &#39;dual&#39;:

        if kind == &#39;timbre&#39;:
            fig, axs = plt.subplots(1, 2, figsize=(8, 4), subplot_kw={&#39;projection&#39;: &#39;polar&#39;})
            for sound, ax in zip(self.sounds, axs):
                plt.sca(ax)
                sound.signal.old_plot(kind, **kwargs)
                ax.set_title(kind + &#39; &#39; + sound.name)

        else:
            fig, axs = plt.subplots(1, 2, figsize=(12, 4))
            for sound, ax in zip(self.sounds, axs):
                plt.sca(ax)
                sound.signal.old_plot(kind, **kwargs)
                ax.set_title(kind + &#39; &#39; + sound.name)
        plt.tight_layout()

    # If a multiple SoundPack : plot on a grid of axes
    elif self.kind == &#39;multiple&#39;:

        # find the n, m values for the subplots line and columns
        n = len(self.sounds)
        if n // 4 &gt;= 10:
            # a lot of sounds
            cols = 4
        elif n // 3 &gt;= 10:
            # many sounds
            cols = 3
        elif n // 2 &lt;= 4:
            # a few sounds
            cols = 2

        remainder = n % cols
        if remainder == 0:
            rows = n // cols
        else:
            rows = n // cols + 1

        fig, axs = plt.subplots(rows, cols, figsize=(12, 4 * rows))
        axs = axs.reshape(-1)
        for sound, ax in zip(self.sounds, axs):
            plt.sca(ax)
            sound.signal.old_plot(kind, **kwargs)
            title = ax.get_title()
            title = sound.name + &#39; &#39; + title
            ax.set_title(title)

        if remainder != 0:
            for ax in axs[-(cols - remainder):]:
                ax.set_axis_off()

        plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.equalize_time"><code class="name flex">
<span>def <span class="ident">equalize_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Trim the sounds so that they all have the length of the shortest sound, trimming is done at the end.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equalize_time(self):
    &#34;&#34;&#34;
    Trim the sounds so that they all have the length of the shortest sound, trimming is done at the end.
    :return: None
    &#34;&#34;&#34;
    trim_index = np.min([len(sound.signal.signal) for sound in self.sounds])
    trimmed_sounds = []
    for sound in self.sounds:
        new_sound = sound
        new_sound.signal = new_sound.signal.trim_time(trim_index / sound.signal.sr)
        new_sound.bin_divide()
        trimmed_sounds.append(new_sound)
    self.sounds = trimmed_sounds</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.fft_diff"><code class="name flex">
<span>def <span class="ident">fft_diff</span></span>(<span>self, fraction=3, ticks=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the difference between the spectral distribution in the two sounds</p>
<p><strong> Dual SoundPack Method </strong>
Compare the Fourier Transform of two sounds by computing the differences of the octave bins heights.
The two FTs are superimposed on the first plot to show differences
The difference between the two FTs is plotted on the second plot</p>
<p>:param fraction: octave fraction value used to compute the frequency bins A higher number will show
a more precise comparison, but conclusions may be harder to draw.
:param ticks:
If True the frequency bins intervals are used as X axis ticks
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fft_diff(self, fraction=3, ticks=None):
    &#34;&#34;&#34;
    Plot the difference between the spectral distribution in the two sounds

    __ Dual SoundPack Method __
    Compare the Fourier Transform of two sounds by computing the differences of the octave bins heights.
    The two FTs are superimposed on the first plot to show differences
    The difference between the two FTs is plotted on the second plot

    :param fraction: octave fraction value used to compute the frequency bins A higher number will show
    a more precise comparison, but conclusions may be harder to draw.
    :param ticks:  If True the frequency bins intervals are used as X axis ticks
    :return: None
    &#34;&#34;&#34;
    if self.kind == &#39;dual&#39;:
        # Separate the sounds
        son1 = self.sounds[0]
        son2 = self.sounds[1]

        # Compute plotting bins
        x_values = utils.octave_values(fraction)
        hist_bins = utils.octave_histogram(fraction)
        bar_widths = np.array([hist_bins[i + 1] - hist_bins[i] for i in range(0, len(hist_bins) - 1)])

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
        plot1 = ax1.hist(son1.signal.fft_bins(), utils.octave_histogram(fraction), color=&#39;blue&#39;, alpha=0.6,
                         label=son1.name)
        plot2 = ax1.hist(son2.signal.fft_bins(), utils.octave_histogram(fraction), color=&#39;orange&#39;, alpha=0.6,
                         label=son2.name)
        ax1.set_title(&#39;FT Histogram for &#39; + son1.name + &#39; and &#39; + son2.name)
        ax1.set_xscale(&#39;log&#39;)
        ax1.set_xlabel(&#39;Fréquence (Hz)&#39;)
        ax1.set_ylabel(&#39;Amplitude&#39;)
        ax1.grid(&#39;on&#39;)
        ax1.legend()

        diff = plot1[0] - plot2[0]
        n_index = np.where(diff &lt;= 0)[0]
        p_index = np.where(diff &gt;= 0)[0]

        # Negative difference corresponding to sound 2
        ax2.bar(x_values[n_index], diff[n_index], width=bar_widths[n_index], color=&#39;orange&#39;, alpha=0.6)
        # Positive difference corresponding to sound1
        ax2.bar(x_values[p_index], diff[p_index], width=bar_widths[p_index], color=&#39;blue&#39;, alpha=0.6)
        ax2.set_title(&#39;Difference &#39; + son1.name + &#39; - &#39; + son2.name)
        ax2.set_xscale(&#39;log&#39;)
        ax2.set_xlabel(&#39;Fréquence (Hz)&#39;)
        ax2.set_ylabel(&#39;&lt;- Son 2 : Son 1 -&gt;&#39;)
        ax2.grid(&#39;on&#39;)

        if ticks == &#39;bins&#39;:
            labels = [label for label in self.SP.bins.__dict__ if label != &#39;name&#39;]
            labels.append(&#39;brillance&#39;)
            x = [param.value for param in self.SP.bins.__dict__.values() if param != &#39;bins&#39;]
            x.append(11250)
            x_formatter = ticker.FixedFormatter(labels)
            x_locator = ticker.FixedLocator(x)
            ax1.xaxis.set_major_locator(x_locator)
            ax1.xaxis.set_major_formatter(x_formatter)
            ax1.tick_params(axis=&#34;x&#34;, labelrotation=90)
            ax2.xaxis.set_major_locator(x_locator)
            ax2.xaxis.set_major_formatter(x_formatter)
            ax2.tick_params(axis=&#34;x&#34;, labelrotation=90)

    else:
        print(&#39;Unsupported for multiple sounds SoundPacks&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.fft_mirror"><code class="name flex">
<span>def <span class="ident">fft_mirror</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the Fourier Transforms of two sounds on opposed axis to compare the spectras</p>
<p><strong> Dual SoundPack Method </strong>
The fourier transforms are normalized between 0 and [-1, 1], the y scale is logarithmic
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fft_mirror(self):
    &#34;&#34;&#34;
    Plot the Fourier Transforms of two sounds on opposed axis to compare the spectras

    __ Dual SoundPack Method __
    The fourier transforms are normalized between 0 and [-1, 1], the y scale is logarithmic
    :return: None
    &#34;&#34;&#34;
    if self.kind == &#39;dual&#39;:
        son1 = self.sounds[0]
        son2 = self.sounds[1]
        index = np.where(son1.signal.fft_frequencies() &gt; SP.general.fft_range.value)[0][0]

        plt.figure(figsize=(10, 6))
        plt.yscale(&#39;symlog&#39;)
        plt.grid(&#39;on&#39;)
        plt.plot(son1.signal.fft_frequencies()[:index], son1.signal.fft()[:index], label=son1.name)
        plt.plot(son2.signal.fft_frequencies()[:index], -son2.signal.fft()[:index], label=son2.name)
        plt.xlabel(&#39;Fréquence (Hz)&#39;)
        plt.ylabel(&#39;Amplitude&#39;)
        plt.title(&#39;Mirror Fourier Transform for &#39; + son1.name + &#39; and &#39; + son2.name)
        plt.legend()

    else:
        print(&#39;Unsupported for multiple sounds SoundPacks&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.freq_bin_plot"><code class="name flex">
<span>def <span class="ident">freq_bin_plot</span></span>(<span>self, f_bin='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the log envelop of specified frequency bins</p>
<p><strong> Multiple SoundPack Method </strong>
A function to compare signals decomposed frequency wise in the time domain on a logarithm scale.
The methods plots all the sounds and plots their frequency bins according to the frequency bin argument f_bin.</p>
<p>Example : SoundPack.freq_bin_plot(f_bin='mid') will plot the log-scale envelop of the 'mid' signal of every
sound in the SoundPack</p>
<p>f_bin: frequency bins to compare, Supported arguments are :
'all', 'bass', 'mid', 'highmid', 'uppermid', 'presence', 'brillance'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freq_bin_plot(self, f_bin=&#39;all&#39;):
    &#34;&#34;&#34;
    Plots the log envelop of specified frequency bins

    __ Multiple SoundPack Method __
    A function to compare signals decomposed frequency wise in the time domain on a logarithm scale.
    The methods plots all the sounds and plots their frequency bins according to the frequency bin argument f_bin.

    Example : SoundPack.freq_bin_plot(f_bin=&#39;mid&#39;) will plot the log-scale envelop of the &#39;mid&#39; signal of every
    sound in the SoundPack

    f_bin: frequency bins to compare, Supported arguments are :
    &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
    &#34;&#34;&#34;

    if f_bin == &#39;all&#39;:
        # Create one plot per bin
        fig, axs = plt.subplots(3, 2, figsize=(12, 12))
        axs = axs.reshape(-1)
        for key, ax in zip([*list(self.SP.bins.__dict__.keys())[1:], &#39;brillance&#39;], axs):
            plt.sca(ax)
            # plot every sound for a frequency bin
            norm_factors = np.array([son.bins[key].normalize().norm_factor for son in self.sounds])
            for i, son in enumerate(self.sounds):
                son.bins[key].normalize().old_plot(&#39;log envelop&#39;, label=son.name)
            plt.xscale(&#39;log&#39;)
            plt.legend()
            title0 = &#39; &#39; + key + &#39; : &#39; + str(int(son.bins[key].range[0])) + &#39; - &#39; + str(
                    int(son.bins[key].range[1])) + &#39; Hz, &#39;
            title1 = &#39;Norm. Factors : &#39;
            title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
            plt.title(title0 + title1 + title2)
        plt.tight_layout()

    elif f_bin in [*list(SP.bins.__dict__.keys())[1:], &#39;brillance&#39;]:
        plt.figure(figsize=(10, 4))
        # Plot every envelop for a single frequency bin
        norm_factors = np.array([son.bins[f_bin].normalize().norm_factor for son in self.sounds])
        for i, son in enumerate(self.sounds):
            son.bins[f_bin].normalize().old_plot(&#39;log envelop&#39;, label=(str(i + 1) + &#39;. &#39; + son.name))
        plt.xscale(&#39;log&#39;)
        plt.legend()
        title0 = &#39; &#39; + f_bin + &#39; : &#39; + str(int(son.bins[f_bin].range[0])) + &#39; - &#39; + str(
            int(son.bins[f_bin].range[1])) + &#39; Hz, &#39;
        title1 = &#39;Norm. Factors : &#39;
        title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
        plt.title(title0 + title1 + title2)

    else:
        print(&#39;invalid frequency bin&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.fundamentals"><code class="name flex">
<span>def <span class="ident">fundamentals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Multiple Soundpack Method </strong>
Displays the fundamentals of every sound in the SoundPack
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fundamentals(self):
    &#34;&#34;&#34;
    __ Multiple Soundpack Method __
    Displays the fundamentals of every sound in the SoundPack
    :return: None
    &#34;&#34;&#34;
    names = np.array([sound.name for sound in self.sounds])
    fundamentals = np.array([np.around(sound.fundamental, 1) for sound in self.sounds])
    key = np.argsort(fundamentals)
    table_data = [names[key], fundamentals[key]]

    table_data = np.array(table_data).transpose()

    print(tabulate(table_data, headers=[&#39;Name&#39;, &#39;Fundamental (Hz)&#39;]))</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.integral_compare"><code class="name flex">
<span>def <span class="ident">integral_compare</span></span>(<span>self, f_bin='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Cumulative bin envelop integral comparison for two signals</p>
<p><strong> Dual SoundPack Method </strong>
Plots the cumulative integral plot of specified frequency bins
and their difference as surfaces</p>
<p>f_bin: frequency bins to compare, Supported arguments are :
'all', 'bass', 'mid', 'highmid', 'uppermid', 'presence', 'brillance'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integral_compare(self, f_bin=&#39;all&#39;):
    &#34;&#34;&#34;
      Cumulative bin envelop integral comparison for two signals

      __ Dual SoundPack Method __
      Plots the cumulative integral plot of specified frequency bins
      and their difference as surfaces

      f_bin: frequency bins to compare, Supported arguments are :
      &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
      &#34;&#34;&#34;

    # Case when plotting all the frequency bins
    if f_bin == &#39;all&#39;:
        fig, axs = plt.subplots(3, 2, figsize=(16, 16))
        axs = axs.reshape(-1)

        self.bin_strings = self.sounds[0].bins.keys()
        bins1 = self.sounds[0].bins.values()
        bins2 = self.sounds[1].bins.values()

        for signal1, signal2, bin_string, ax in zip(bins1, bins2, self.bin_strings, axs):
            log_envelop1, log_time1 = signal1.normalize().log_envelop()
            log_envelop2, log_time2 = signal2.normalize().log_envelop()
            integ = scipy.integrate.trapezoid

            integral1 = np.array([integ(log_envelop1[:i], log_time1[:i]) for i in np.arange(2, len(log_envelop1), 1)])
            integral2 = np.array([integ(log_envelop2[:i], log_time2[:i]) for i in np.arange(2, len(log_envelop2), 1)])
            time1 = log_time1[2:len(log_time1):1]
            time2 = log_time2[2:len(log_time2):1]

            int_index = np.min([integral1.shape[0], integral2.shape[0]])
            ax.fill_between(time1, integral1, label=self.sounds[0].name, alpha=0.4)
            ax.fill_between(time2, -integral2, label=self.sounds[1].name, alpha=0.4)
            ax.fill_between(time2, integral1 - integral2, color=&#39;g&#39;, label=&#39;int diff&#39;, alpha=0.6)

            ax.set_xlabel(&#39;time (s)&#39;)
            ax.set_ylabel(&#39;cummulative power&#39;)
            ax.set_xscale(&#39;log&#39;)
            ax.set_title(bin_string)
            ax.legend()
            ax.grid(&#39;on&#39;)
        plt.tight_layout()

    elif f_bin in self.bin_strings:
        fig, ax = plt.subplots(figsize=(8, 6))
        signal1 = self.sounds[0].bins[f_bin]
        signal2 = self.sounds[1].bins[f_bin]
        log_envelop1, log_time1 = signal1.normalize().log_envelop()
        log_envelop2, log_time2 = signal2.normalize().log_envelop()
        integ = scipy.integrate.trapezoid

        integral1 = np.array([integ(log_envelop1[:i], log_time1[:i]) for i in np.arange(2, len(log_envelop1), 1)])
        integral2 = np.array([integ(log_envelop2[:i], log_time2[:i]) for i in np.arange(2, len(log_envelop2), 1)])
        time1 = log_time1[2:len(log_time1):1]
        time2 = log_time2[2:len(log_time2):1]

        int_index = np.min([integral1.shape[0], integral2.shape[0]])
        ax.fill_between(time1, integral1, label=self.sounds[0].name, alpha=0.4)
        ax.fill_between(time2, -integral2, label=self.sounds[1].name, alpha=0.4)
        ax.fill_between(time2, integral1 - integral2, color=&#39;g&#39;, label=&#39;int diff&#39;, alpha=0.6)

        ax.set_xlabel(&#39;time (s)&#39;)
        ax.set_ylabel(&#39;cummulative power&#39;)
        ax.set_xscale(&#39;log&#39;)
        ax.set_title(f_bin)
        ax.legend(loc=&#39;upper left&#39;)
        ax.grid(&#39;on&#39;)

    else:
        print(&#39;invalid frequency bin&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.integral_plot"><code class="name flex">
<span>def <span class="ident">integral_plot</span></span>(<span>self, f_bin='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Normalized cumulative bin power plot for the frequency bins</p>
<p><strong> Multiple SoundPack Method </strong>
Plots the cumulative integral plot of specified frequency bins
see help(Plot.integral)</p>
<p>f_bin: frequency bins to compare, Supported arguments are :
'all', 'bass', 'mid', 'highmid', 'uppermid', 'presence', 'brillance'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integral_plot(self, f_bin=&#39;all&#39;):
    &#34;&#34;&#34;
    Normalized cumulative bin power plot for the frequency bins

    __ Multiple SoundPack Method __
    Plots the cumulative integral plot of specified frequency bins
    see help(Plot.integral)

    f_bin: frequency bins to compare, Supported arguments are :
    &#39;all&#39;, &#39;bass&#39;, &#39;mid&#39;, &#39;highmid&#39;, &#39;uppermid&#39;, &#39;presence&#39;, &#39;brillance&#39;
    &#34;&#34;&#34;

    if f_bin == &#39;all&#39;:
        # create a figure with 6 axes
        fig, axs = plt.subplots(3, 2, figsize=(12, 12))
        axs = axs.reshape(-1)

        for key, ax in zip(self.bin_strings, axs):
            plt.sca(ax)
            norm_factors = np.array([son.bins[key].normalize().norm_factor for son in self.sounds])
            for sound in self.sounds:
                sound.bins[key].plot.integral(label=sound.name)
            plt.legend()
            title0 = &#39; &#39; + key + &#39; : &#39; + str(int(sound.bins[key].range[0])) + &#39; - &#39; + str(
                int(sound.bins[key].range[1])) + &#39; Hz, &#39;
            title1 = &#39;Norm. Factors : &#39;
            title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
            plt.title(title0 + title1 + title2)
            plt.title(title0 + title1 + title2)
        plt.tight_layout()

    elif f_bin in self.bin_strings:
        fig, ax = plt.subplots(figsize=(6, 4))
        plt.sca(ax)
        norm_factors = np.array([son.bins[f_bin].normalize().norm_factor for son in self.sounds])
        for sound in self.sounds:
            sound.bins[f_bin].plot.integral(label=sound.name)
        plt.legend()
        title0 = &#39; &#39; + f_bin + &#39; : &#39; + str(int(sound.bins[f_bin].range[0])) + &#39; - &#39; + str(
            int(sound.bins[f_bin].range[1])) + &#39; Hz, &#39;
        title1 = &#39;Norm. Factors : &#39;
        title2 = &#39;x, &#39;.join(str(np.around(norm_factor, 0)) for norm_factor in norm_factors)
        plt.title(title0 + title1 + title2)

    else:
        print(&#39;invalid frequency bin&#39;)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize all the signals in the SoundPack and returns a normaized
instance of itself
:return: SoundPack with normalized signals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(self):
    &#34;&#34;&#34;
    Normalize all the signals in the SoundPack and returns a normaized
    instance of itself
    :return: SoundPack with normalized signals
    &#34;&#34;&#34;
    new_sounds = []
    names = [sound.name for sound in self.sounds]
    fundamentals = [sound.fundamental for sound in self.sounds]
    for sound in self.sounds:
        sound.signal = sound.signal.normalize()
        new_sounds.append(sound)

    return SoundPack(new_sounds, names=names, fundamentals=fundamentals, SoundParams=self.SP, equalize_time=False)</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, kind, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Superimposed plot of all the sounds on one figure for a specific kind</p>
<p><strong> Multiple SoundPack Method </strong>
Plots a specific signal.plot for all sounds on the same figure
Ex : compare_plot('fft') plots the fft of all sounds on a single figure
The color argument is set to none so that the plots have different colors</p>
<p>:param kind: Attribute passed to the <code>signal.plot()</code> method
:param kwargs: key words arguments to pass to the <code>signal.plot()</code> method
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, kind, **kwargs):
    &#34;&#34;&#34;
    Superimposed plot of all the sounds on one figure for a specific kind

    __ Multiple SoundPack Method __
    Plots a specific signal.plot for all sounds on the same figure
    Ex : compare_plot(&#39;fft&#39;) plots the fft of all sounds on a single figure
    The color argument is set to none so that the plots have different colors

    :param kind: Attribute passed to the `signal.plot()` method
    :param kwargs: key words arguments to pass to the `signal.plot()` method
    :return: None
    &#34;&#34;&#34;
    plt.figure(figsize=(8, 6))
    for sound in self.sounds:
        kwargs[&#39;label&#39;] = sound.name
        kwargs[&#39;color&#39;] = None
        sound.signal.old_plot(kind, **kwargs)

    plt.title(kind + &#39; plot&#39;)
    if kind == &#39;timbre&#39;:
        plt.legend(bbox_to_anchor=(1.3, 0.9))
    else:
        plt.legend()</code></pre>
</details>
</dd>
<dt id="guitarsounds.analysis.SoundPack.sounds_from_files"><code class="name flex">
<span>def <span class="ident">sounds_from_files</span></span>(<span>self, sound_files, names=None, fundamentals=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create Sound class instances and assign them to the SoundPack from a list of files
:param sound_files: sound filenames
:param names: sound names
:param fundamentals: user specified fundamental frequencies
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sounds_from_files(self, sound_files, names=None, fundamentals=None):
    &#34;&#34;&#34;
    Create Sound class instances and assign them to the SoundPack from a list of files
    :param sound_files: sound filenames
    :param names: sound names
    :param fundamentals: user specified fundamental frequencies
    :return: None
    &#34;&#34;&#34;
    # Make the default name list from sound filenames if none is supplied
    if (names is None) or (len(names) != len(sound_files)):
        names = [file[:-4] for file in sound_files]  # remove the .wav

    # If the fundamentals are not supplied or mismatch in number None is used
    if (fundamentals is None) or (len(fundamentals) != len(sound_files)):
        fundamentals = len(sound_files) * [None]

    # Create Sound instances from files
    self.sounds = []
    for file, name, fundamental in zip(sound_files, names, fundamentals):
        self.sounds.append(Sound(file, name=name, fundamental=fundamental,
                                 SoundParams=self.SP).condition(return_self=True))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="guitarsounds" href="index.html">guitarsounds</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="guitarsounds.analysis.SP" href="#guitarsounds.analysis.SP">SP</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="guitarsounds.analysis.Plot" href="#guitarsounds.analysis.Plot">Plot</a></code></h4>
<ul class="two-column">
<li><code><a title="guitarsounds.analysis.Plot.envelop" href="#guitarsounds.analysis.Plot.envelop">envelop</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.fft" href="#guitarsounds.analysis.Plot.fft">fft</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.fft_hist" href="#guitarsounds.analysis.Plot.fft_hist">fft_hist</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.illegal_kwargs" href="#guitarsounds.analysis.Plot.illegal_kwargs">illegal_kwargs</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.integral" href="#guitarsounds.analysis.Plot.integral">integral</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.log_envelop" href="#guitarsounds.analysis.Plot.log_envelop">log_envelop</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.peak_damping" href="#guitarsounds.analysis.Plot.peak_damping">peak_damping</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.peaks" href="#guitarsounds.analysis.Plot.peaks">peaks</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.sanitize_kwargs" href="#guitarsounds.analysis.Plot.sanitize_kwargs">sanitize_kwargs</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.set_bin_ticks" href="#guitarsounds.analysis.Plot.set_bin_ticks">set_bin_ticks</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.signal" href="#guitarsounds.analysis.Plot.signal">signal</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.timbre" href="#guitarsounds.analysis.Plot.timbre">timbre</a></code></li>
<li><code><a title="guitarsounds.analysis.Plot.time_damping" href="#guitarsounds.analysis.Plot.time_damping">time_damping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="guitarsounds.analysis.Signal" href="#guitarsounds.analysis.Signal">Signal</a></code></h4>
<ul class="two-column">
<li><code><a title="guitarsounds.analysis.Signal.cavity_frequency" href="#guitarsounds.analysis.Signal.cavity_frequency">cavity_frequency</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.cavity_peak" href="#guitarsounds.analysis.Signal.cavity_peak">cavity_peak</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.envelop" href="#guitarsounds.analysis.Signal.envelop">envelop</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.envelop_time" href="#guitarsounds.analysis.Signal.envelop_time">envelop_time</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.fft" href="#guitarsounds.analysis.Signal.fft">fft</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.fft_bins" href="#guitarsounds.analysis.Signal.fft_bins">fft_bins</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.fft_frequencies" href="#guitarsounds.analysis.Signal.fft_frequencies">fft_frequencies</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.filter_noise" href="#guitarsounds.analysis.Signal.filter_noise">filter_noise</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.find_onset" href="#guitarsounds.analysis.Signal.find_onset">find_onset</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.fundamental" href="#guitarsounds.analysis.Signal.fundamental">fundamental</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.listen" href="#guitarsounds.analysis.Signal.listen">listen</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.log_envelop" href="#guitarsounds.analysis.Signal.log_envelop">log_envelop</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.make_freq_bins" href="#guitarsounds.analysis.Signal.make_freq_bins">make_freq_bins</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.normalize" href="#guitarsounds.analysis.Signal.normalize">normalize</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.old_plot" href="#guitarsounds.analysis.Signal.old_plot">old_plot</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.peak_damping" href="#guitarsounds.analysis.Signal.peak_damping">peak_damping</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.peaks" href="#guitarsounds.analysis.Signal.peaks">peaks</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.save_wav" href="#guitarsounds.analysis.Signal.save_wav">save_wav</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.timbre" href="#guitarsounds.analysis.Signal.timbre">timbre</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.time" href="#guitarsounds.analysis.Signal.time">time</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.time_damping" href="#guitarsounds.analysis.Signal.time_damping">time_damping</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.trim_onset" href="#guitarsounds.analysis.Signal.trim_onset">trim_onset</a></code></li>
<li><code><a title="guitarsounds.analysis.Signal.trim_time" href="#guitarsounds.analysis.Signal.trim_time">trim_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="guitarsounds.analysis.Sound" href="#guitarsounds.analysis.Sound">Sound</a></code></h4>
<ul class="two-column">
<li><code><a title="guitarsounds.analysis.Sound.bin_divide" href="#guitarsounds.analysis.Sound.bin_divide">bin_divide</a></code></li>
<li><code><a title="guitarsounds.analysis.Sound.bin_hist" href="#guitarsounds.analysis.Sound.bin_hist">bin_hist</a></code></li>
<li><code><a title="guitarsounds.analysis.Sound.condition" href="#guitarsounds.analysis.Sound.condition">condition</a></code></li>
<li><code><a title="guitarsounds.analysis.Sound.filter_noise" href="#guitarsounds.analysis.Sound.filter_noise">filter_noise</a></code></li>
<li><code><a title="guitarsounds.analysis.Sound.listen_freq_bins" href="#guitarsounds.analysis.Sound.listen_freq_bins">listen_freq_bins</a></code></li>
<li><code><a title="guitarsounds.analysis.Sound.peak_damping" href="#guitarsounds.analysis.Sound.peak_damping">peak_damping</a></code></li>
<li><code><a title="guitarsounds.analysis.Sound.plot_freq_bins" href="#guitarsounds.analysis.Sound.plot_freq_bins">plot_freq_bins</a></code></li>
<li><code><a title="guitarsounds.analysis.Sound.trim_signal" href="#guitarsounds.analysis.Sound.trim_signal">trim_signal</a></code></li>
<li><code><a title="guitarsounds.analysis.Sound.use_raw_signal" href="#guitarsounds.analysis.Sound.use_raw_signal">use_raw_signal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="guitarsounds.analysis.SoundPack" href="#guitarsounds.analysis.SoundPack">SoundPack</a></code></h4>
<ul class="two-column">
<li><code><a title="guitarsounds.analysis.SoundPack.bin_power_hist" href="#guitarsounds.analysis.SoundPack.bin_power_hist">bin_power_hist</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.bin_power_table" href="#guitarsounds.analysis.SoundPack.bin_power_table">bin_power_table</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.coherence_plot" href="#guitarsounds.analysis.SoundPack.coherence_plot">coherence_plot</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.combine_envelop" href="#guitarsounds.analysis.SoundPack.combine_envelop">combine_envelop</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.compare_peaks" href="#guitarsounds.analysis.SoundPack.compare_peaks">compare_peaks</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.compare_plot" href="#guitarsounds.analysis.SoundPack.compare_plot">compare_plot</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.equalize_time" href="#guitarsounds.analysis.SoundPack.equalize_time">equalize_time</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.fft_diff" href="#guitarsounds.analysis.SoundPack.fft_diff">fft_diff</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.fft_mirror" href="#guitarsounds.analysis.SoundPack.fft_mirror">fft_mirror</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.freq_bin_plot" href="#guitarsounds.analysis.SoundPack.freq_bin_plot">freq_bin_plot</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.fundamentals" href="#guitarsounds.analysis.SoundPack.fundamentals">fundamentals</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.integral_compare" href="#guitarsounds.analysis.SoundPack.integral_compare">integral_compare</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.integral_plot" href="#guitarsounds.analysis.SoundPack.integral_plot">integral_plot</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.normalize" href="#guitarsounds.analysis.SoundPack.normalize">normalize</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.plot" href="#guitarsounds.analysis.SoundPack.plot">plot</a></code></li>
<li><code><a title="guitarsounds.analysis.SoundPack.sounds_from_files" href="#guitarsounds.analysis.SoundPack.sounds_from_files">sounds_from_files</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>